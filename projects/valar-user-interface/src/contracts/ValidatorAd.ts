/* eslint-disable */
// @ts-nocheck
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils'
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  AppStorageSchema,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from '@algorandfoundation/algokit-utils/types/app'
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from '@algorandfoundation/algokit-utils/types/app-client'
import type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'
import type { SendTransactionResult, TransactionToSign, SendTransactionFrom, SendTransactionParams } from '@algorandfoundation/algokit-utils/types/transaction'
import type { ABIResult, TransactionWithSigner } from 'algosdk'
import { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer, modelsv2 } from 'algosdk'
export const APP_SPEC: AppSpec = {
  "hints": {
    "ad_create(address)uint64": {
      "call_config": {
        "no_op": "CREATE"
      }
    },
    "ad_config(address,address,bool,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "ad_delete(address)void": {
      "call_config": {
        "delete_application": "CALL"
      }
    },
    "ad_ready(address,bool)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "ad_self_disclose(address,(byte[30],byte[60],byte[2],uint64,byte[20]))void": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "val_info": {
          "name": "ValidatorSelfDisclosure",
          "elements": [
            [
              "name",
              "byte[30]"
            ],
            [
              "https",
              "byte[60]"
            ],
            [
              "country_code",
              "byte[2]"
            ],
            [
              "hw_cat",
              "uint64"
            ],
            [
              "node_version",
              "byte[20]"
            ]
          ]
        }
      }
    },
    "ad_terms(address,byte[32],(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64),((uint64,uint64)[2]),(uint64,uint64),pay)void": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "terms_time": {
          "name": "ValidatorTermsTiming",
          "elements": [
            [
              "rounds_setup",
              "uint64"
            ],
            [
              "rounds_confirm",
              "uint64"
            ],
            [
              "rounds_duration_min",
              "uint64"
            ],
            [
              "rounds_duration_max",
              "uint64"
            ],
            [
              "round_max_end",
              "uint64"
            ]
          ]
        },
        "terms_price": {
          "name": "ValidatorTermsPricing",
          "elements": [
            [
              "commission",
              "uint64"
            ],
            [
              "fee_round_min",
              "uint64"
            ],
            [
              "fee_round_var",
              "uint64"
            ],
            [
              "fee_setup",
              "uint64"
            ],
            [
              "fee_asset_id",
              "uint64"
            ]
          ]
        },
        "terms_stake": {
          "name": "ValidatorTermsStakeLimits",
          "elements": [
            [
              "stake_max",
              "uint64"
            ],
            [
              "stake_gratis",
              "uint64"
            ]
          ]
        },
        "terms_reqs": {
          "name": "ValidatorTermsGating",
          "elements": [
            [
              "gating_asa_list",
              "(uint64,uint64)[2]"
            ]
          ]
        },
        "terms_warn": {
          "name": "ValidatorTermsWarnings",
          "elements": [
            [
              "cnt_warning_max",
              "uint64"
            ],
            [
              "rounds_warning",
              "uint64"
            ]
          ]
        }
      }
    },
    "ad_income(address,uint64)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "ad_asa_close(address,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "template_load_init(address,uint64,pay)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "template_load_data(address,uint64,byte[])void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "template_load_end(address)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "contract_create(address,address,uint64,uint64,address,(uint64,uint64),pay,txn)uint64": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "partner_commissions": {
          "name": "PartnerCommissions",
          "elements": [
            [
              "commission_setup",
              "uint64"
            ],
            [
              "commission_operational",
              "uint64"
            ]
          ]
        }
      }
    },
    "keys_confirm(address,application)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "keys_not_confirmed(application)(address,byte[100])": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "output": {
          "name": "Message",
          "elements": [
            [
              "del_manager",
              "address"
            ],
            [
              "msg",
              "byte[100]"
            ]
          ]
        }
      }
    },
    "keys_not_submitted(application)(address,byte[100])": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "output": {
          "name": "Message",
          "elements": [
            [
              "del_manager",
              "address"
            ],
            [
              "msg",
              "byte[100]"
            ]
          ]
        }
      }
    },
    "keys_submit(address,application,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address))(address,byte[100])": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "key_reg_txn_info": {
          "name": "KeyRegTxnInfo",
          "elements": [
            [
              "vote_first",
              "uint64"
            ],
            [
              "vote_last",
              "uint64"
            ],
            [
              "vote_key_dilution",
              "uint64"
            ],
            [
              "vote_pk",
              "byte[32]"
            ],
            [
              "selection_pk",
              "byte[32]"
            ],
            [
              "state_proof_pk",
              "byte[64]"
            ],
            [
              "sender",
              "address"
            ]
          ]
        },
        "output": {
          "name": "Message",
          "elements": [
            [
              "del_manager",
              "address"
            ],
            [
              "msg",
              "byte[100]"
            ]
          ]
        }
      }
    },
    "breach_limits(application)(bool,(uint64,uint64,uint64),address,byte[100])": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "output": {
          "name": "BreachLimitsReturn",
          "elements": [
            [
              "max_breach_reached",
              "bool"
            ],
            [
              "earnings_distribution",
              "(uint64,uint64,uint64)"
            ],
            [
              "del_manager",
              "address"
            ],
            [
              "msg",
              "byte[100]"
            ]
          ]
        }
      }
    },
    "breach_pay(application)(address,byte[100])": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "output": {
          "name": "Message",
          "elements": [
            [
              "del_manager",
              "address"
            ],
            [
              "msg",
              "byte[100]"
            ]
          ]
        }
      }
    },
    "breach_suspended(application)((uint64,uint64,uint64),address,byte[100])": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "output": {
          "name": "EarningsDistributionAndMessage",
          "elements": [
            [
              "earnings_distribution",
              "(uint64,uint64,uint64)"
            ],
            [
              "del_manager",
              "address"
            ],
            [
              "msg",
              "byte[100]"
            ]
          ]
        }
      }
    },
    "contract_claim(application)(uint64,uint64,uint64)": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "output": {
          "name": "EarningsDistribution",
          "elements": [
            [
              "user",
              "uint64"
            ],
            [
              "platform",
              "uint64"
            ],
            [
              "asset_id",
              "uint64"
            ]
          ]
        }
      }
    },
    "contract_expired(application)(address,byte[100])": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "output": {
          "name": "Message",
          "elements": [
            [
              "del_manager",
              "address"
            ],
            [
              "msg",
              "byte[100]"
            ]
          ]
        }
      }
    },
    "contract_withdraw(address,application)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "contract_delete(address,application)(uint64,uint64)": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "output": {
          "name": "ContractDeleteReturn",
          "elements": [
            [
              "remaining_balance",
              "uint64"
            ],
            [
              "asset_id",
              "uint64"
            ]
          ]
        }
      }
    },
    "contract_report_expiry_soon(uint64,uint64,application)(address,byte[100])": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "output": {
          "name": "Message",
          "elements": [
            [
              "del_manager",
              "address"
            ],
            [
              "msg",
              "byte[100]"
            ]
          ]
        }
      }
    },
    "gas()void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "get_validator_asa(uint64)(uint64,uint64)": {
      "read_only": true,
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "output": {
          "name": "ValidatorASA",
          "elements": [
            [
              "total_earning",
              "uint64"
            ],
            [
              "total_fees_generated",
              "uint64"
            ]
          ]
        }
      }
    }
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLl9fYWxnb3B5X2VudHJ5cG9pbnRfd2l0aF9pbml0KCkgLT4gdWludDY0OgptYWluOgogICAgaW50Y2Jsb2NrIDAgMSA2IDEwMDAwMDAgNDA5NgogICAgYnl0ZWNibG9jayAweDE1MWY3Yzc1ICJzdGF0ZSIgInZhbF9vd25lciIgMHg2NCAiY250X2RlbCIgImRlbF9hcHBfbGlzdCIgIlQiICJQIiAiY250X2FzYSIgIlMiICJXIiAidmFsX21hbmFnZXIiIDB4MDIgMHg2MTczNjE1ZiAibm90aWNlYm9hcmRfYXBwX2lkIiAidGNfc2hhMjU2IiAiRyIgImNudF9kZWxfbWF4IiAidG90YWxfYWxnb19lYXJuZWQiICJ0b3RhbF9hbGdvX2ZlZXNfZ2VuZXJhdGVkIiAweDAxIDB4MDMgMHgwNiAweDA1IDB4MDAwMDAwMDAwMDAwMDAwMAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGJueiBtYWluX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTozNTkKICAgIC8vIHNlbGYubm90aWNlYm9hcmRfYXBwX2lkID0gVUludDY0KDApCiAgICBieXRlYyAxNCAvLyAibm90aWNlYm9hcmRfYXBwX2lkIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjM2MQogICAgLy8gc2VsZi50Y19zaGEyNTYgPSBTaGEyNTYuZnJvbV9ieXRlcyhvcC5iemVybygzMikpCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICBiemVybwogICAgYnl0ZWMgMTUgLy8gInRjX3NoYTI1NiIKICAgIGRpZyAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTozNjQKICAgIC8vIFZhbGlkYXRvclRlcm1zVGltaW5nLmZyb21fYnl0ZXMob3AuYnplcm8oNDApKSwKICAgIHB1c2hpbnQgNDAgLy8gNDAKICAgIGJ6ZXJvCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjM2NQogICAgLy8ga2V5PSJUIiwKICAgIGJ5dGVjIDYgLy8gIlQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjM2My0zNjYKICAgIC8vIHNlbGYudGVybXNfdGltZSA9IEdsb2JhbFN0YXRlKAogICAgLy8gICAgIFZhbGlkYXRvclRlcm1zVGltaW5nLmZyb21fYnl0ZXMob3AuYnplcm8oNDApKSwKICAgIC8vICAgICBrZXk9IlQiLAogICAgLy8gKQogICAgZGlnIDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjM2OQogICAgLy8ga2V5PSJQIiwKICAgIGJ5dGVjIDcgLy8gIlAiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjM2Ny0zNzAKICAgIC8vIHNlbGYudGVybXNfcHJpY2UgPSBHbG9iYWxTdGF0ZSgKICAgIC8vICAgICBWYWxpZGF0b3JUZXJtc1ByaWNpbmcuZnJvbV9ieXRlcyhvcC5iemVybyg0MCkpLAogICAgLy8gICAgIGtleT0iUCIsCiAgICAvLyApCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTozNzIKICAgIC8vIFZhbGlkYXRvclRlcm1zU3Rha2VMaW1pdHMuZnJvbV9ieXRlcyhvcC5iemVybygxNikpLAogICAgcHVzaGludCAxNiAvLyAxNgogICAgYnplcm8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MzczCiAgICAvLyBrZXk9IlMiLAogICAgYnl0ZWMgOSAvLyAiUyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MzcxLTM3NAogICAgLy8gc2VsZi50ZXJtc19zdGFrZSA9IEdsb2JhbFN0YXRlKAogICAgLy8gICAgIFZhbGlkYXRvclRlcm1zU3Rha2VMaW1pdHMuZnJvbV9ieXRlcyhvcC5iemVybygxNikpLAogICAgLy8gICAgIGtleT0iUyIsCiAgICAvLyApCiAgICBkaWcgMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6Mzc3CiAgICAvLyBrZXk9IkciLAogICAgYnl0ZWMgMTYgLy8gIkciCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjM3NS0zNzgKICAgIC8vIHNlbGYudGVybXNfcmVxcyA9IEdsb2JhbFN0YXRlKAogICAgLy8gICAgIFZhbGlkYXRvclRlcm1zR2F0aW5nLmZyb21fYnl0ZXMob3AuYnplcm8oMzIpKSwKICAgIC8vICAgICBrZXk9IkciLAogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTozODEKICAgIC8vIGtleT0iVyIsCiAgICBieXRlYyAxMCAvLyAiVyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6Mzc5LTM4MgogICAgLy8gc2VsZi50ZXJtc193YXJuID0gR2xvYmFsU3RhdGUoCiAgICAvLyAgICAgVmFsaWRhdG9yVGVybXNXYXJuaW5ncy5mcm9tX2J5dGVzKG9wLmJ6ZXJvKDE2KSksCiAgICAvLyAgICAga2V5PSJXIiwKICAgIC8vICkKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjM4NAogICAgLy8gc2VsZi52YWxfb3duZXIgPSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBieXRlY18yIC8vICJ2YWxfb3duZXIiCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjM4NQogICAgLy8gc2VsZi52YWxfbWFuYWdlciA9IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIGJ5dGVjIDExIC8vICJ2YWxfbWFuYWdlciIKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6Mzg4CiAgICAvLyBWYWxpZGF0b3JTZWxmRGlzY2xvc3VyZS5mcm9tX2J5dGVzKG9wLmJ6ZXJvKDEyMCkpLAogICAgcHVzaGludCAxMjAgLy8gMTIwCiAgICBiemVybwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTozODkKICAgIC8vIGtleT0iViIsCiAgICBwdXNoYnl0ZXMgIlYiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjM4Ny0zOTEKICAgIC8vIHNlbGYudmFsX2luZm8gPSBHbG9iYWxTdGF0ZSgKICAgIC8vICAgICBWYWxpZGF0b3JTZWxmRGlzY2xvc3VyZS5mcm9tX2J5dGVzKG9wLmJ6ZXJvKDEyMCkpLAogICAgLy8gICAgIGtleT0iViIsCiAgICAvLyAgICAgZGVzY3JpcHRpb249IlNlbGYtZGlzY2xvc2VkIGluZm9ybWF0aW9uIGFib3V0IHZhbGlkYXRvci4iCiAgICAvLyApCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTozOTMKICAgIC8vIHNlbGYuc3RhdGUgPSBCeXRlcyhTVEFURV9OT05FKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBwdXNoYnl0ZXMgMHgwMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6Mzk1CiAgICAvLyBzZWxmLmNudF9kZWwgPSBVSW50NjQoMCkKICAgIGJ5dGVjIDQgLy8gImNudF9kZWwiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6Mzk2CiAgICAvLyBzZWxmLmNudF9kZWxfbWF4ID0gVUludDY0KDApCiAgICBieXRlYyAxNyAvLyAiY250X2RlbF9tYXgiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6Mzk4CiAgICAvLyBzZWxmLmRlbF9hcHBfbGlzdCA9IERlbEFwcExpc3QuZnJvbV9ieXRlcyhvcC5iemVybyg4ICogTUFYSU1VTV9OVU1CRVJfT0ZfREVMRUdBVE9SX0NPTlRSQUNUU19QRVJfVkFMSURBVE9SX0FEKSkKICAgIHB1c2hpbnQgMTEyIC8vIDExMgogICAgYnplcm8KICAgIGJ5dGVjIDUgLy8gImRlbF9hcHBfbGlzdCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQwMAogICAgLy8gc2VsZi50b3RhbF9hbGdvX2Vhcm5lZCA9IFVJbnQ2NCgwKQogICAgYnl0ZWMgMTggLy8gInRvdGFsX2FsZ29fZWFybmVkIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQwMQogICAgLy8gc2VsZi50b3RhbF9hbGdvX2ZlZXNfZ2VuZXJhdGVkID0gVUludDY0KDApCiAgICBieXRlYyAxOSAvLyAidG90YWxfYWxnb19mZWVzX2dlbmVyYXRlZCIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo0MDMKICAgIC8vIHNlbGYuY250X2FzYSA9IFVJbnQ2NCgwKQogICAgYnl0ZWMgOCAvLyAiY250X2FzYSIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAoKbWFpbl9hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMS0xMDIKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBWYWxpZGF0b3JBZChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHR4biBOdW1BcHBBcmdzCiAgICBieiBtYWluX2FmdGVyX2lmX2Vsc2VAMzEKICAgIHB1c2hieXRlc3MgMHg3MzRlY2Q3NyAweDkzZjA0ZmU2IDB4ODAzOWUzMjQgMHhhNjkzZGUwMiAweGVmNDIzNTUxIDB4YWQwMzZkZTUgMHg4YmIwN2I1ZiAweDMwYTM4NjU5IDB4ZTBhNGI3MjMgMHg5ZDY0YzZlOSAweGRiZTE2MDVmIDB4YzQ3ZjNiOTMgMHg4MDBmZDJhMSAweGUwMzQwMmVkIDB4NGRkMDliMjYgMHgzOTkwOGRlOSAweDQ5ZGZlZTFhIDB4ZjliNjhlMzIgMHhmODExZmNiNyAweGFjZTAzNjMxIDB4NDU4Y2NiMGMgMHhjNjhkMmRiNSAweDBiZjdkODU1IDB4MTY5MzYxYjkgMHgzMTcyY2E5ZCAweDIyNjgwODYzIC8vIG1ldGhvZCAiYWRfY3JlYXRlKGFkZHJlc3MpdWludDY0IiwgbWV0aG9kICJhZF9jb25maWcoYWRkcmVzcyxhZGRyZXNzLGJvb2wsdWludDY0KXZvaWQiLCBtZXRob2QgImFkX2RlbGV0ZShhZGRyZXNzKXZvaWQiLCBtZXRob2QgImFkX3JlYWR5KGFkZHJlc3MsYm9vbCl2b2lkIiwgbWV0aG9kICJhZF9zZWxmX2Rpc2Nsb3NlKGFkZHJlc3MsKGJ5dGVbMzBdLGJ5dGVbNjBdLGJ5dGVbMl0sdWludDY0LGJ5dGVbMjBdKSl2b2lkIiwgbWV0aG9kICJhZF90ZXJtcyhhZGRyZXNzLGJ5dGVbMzJdLCh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KSwodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCksKHVpbnQ2NCx1aW50NjQpLCgodWludDY0LHVpbnQ2NClbMl0pLCh1aW50NjQsdWludDY0KSxwYXkpdm9pZCIsIG1ldGhvZCAiYWRfaW5jb21lKGFkZHJlc3MsdWludDY0KXVpbnQ2NCIsIG1ldGhvZCAiYWRfYXNhX2Nsb3NlKGFkZHJlc3MsdWludDY0KXZvaWQiLCBtZXRob2QgInRlbXBsYXRlX2xvYWRfaW5pdChhZGRyZXNzLHVpbnQ2NCxwYXkpdm9pZCIsIG1ldGhvZCAidGVtcGxhdGVfbG9hZF9kYXRhKGFkZHJlc3MsdWludDY0LGJ5dGVbXSl2b2lkIiwgbWV0aG9kICJ0ZW1wbGF0ZV9sb2FkX2VuZChhZGRyZXNzKXZvaWQiLCBtZXRob2QgImNvbnRyYWN0X2NyZWF0ZShhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ2NCxhZGRyZXNzLCh1aW50NjQsdWludDY0KSxwYXksdHhuKXVpbnQ2NCIsIG1ldGhvZCAia2V5c19jb25maXJtKGFkZHJlc3MsYXBwbGljYXRpb24pdm9pZCIsIG1ldGhvZCAia2V5c19ub3RfY29uZmlybWVkKGFwcGxpY2F0aW9uKShhZGRyZXNzLGJ5dGVbMTAwXSkiLCBtZXRob2QgImtleXNfbm90X3N1Ym1pdHRlZChhcHBsaWNhdGlvbikoYWRkcmVzcyxieXRlWzEwMF0pIiwgbWV0aG9kICJrZXlzX3N1Ym1pdChhZGRyZXNzLGFwcGxpY2F0aW9uLCh1aW50NjQsdWludDY0LHVpbnQ2NCxieXRlWzMyXSxieXRlWzMyXSxieXRlWzY0XSxhZGRyZXNzKSkoYWRkcmVzcyxieXRlWzEwMF0pIiwgbWV0aG9kICJicmVhY2hfbGltaXRzKGFwcGxpY2F0aW9uKShib29sLCh1aW50NjQsdWludDY0LHVpbnQ2NCksYWRkcmVzcyxieXRlWzEwMF0pIiwgbWV0aG9kICJicmVhY2hfcGF5KGFwcGxpY2F0aW9uKShhZGRyZXNzLGJ5dGVbMTAwXSkiLCBtZXRob2QgImJyZWFjaF9zdXNwZW5kZWQoYXBwbGljYXRpb24pKCh1aW50NjQsdWludDY0LHVpbnQ2NCksYWRkcmVzcyxieXRlWzEwMF0pIiwgbWV0aG9kICJjb250cmFjdF9jbGFpbShhcHBsaWNhdGlvbikodWludDY0LHVpbnQ2NCx1aW50NjQpIiwgbWV0aG9kICJjb250cmFjdF9leHBpcmVkKGFwcGxpY2F0aW9uKShhZGRyZXNzLGJ5dGVbMTAwXSkiLCBtZXRob2QgImNvbnRyYWN0X3dpdGhkcmF3KGFkZHJlc3MsYXBwbGljYXRpb24pdm9pZCIsIG1ldGhvZCAiY29udHJhY3RfZGVsZXRlKGFkZHJlc3MsYXBwbGljYXRpb24pKHVpbnQ2NCx1aW50NjQpIiwgbWV0aG9kICJjb250cmFjdF9yZXBvcnRfZXhwaXJ5X3Nvb24odWludDY0LHVpbnQ2NCxhcHBsaWNhdGlvbikoYWRkcmVzcyxieXRlWzEwMF0pIiwgbWV0aG9kICJnYXMoKXZvaWQiLCBtZXRob2QgImdldF92YWxpZGF0b3JfYXNhKHVpbnQ2NCkodWludDY0LHVpbnQ2NCkiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX2FkX2NyZWF0ZV9yb3V0ZUA1IG1haW5fYWRfY29uZmlnX3JvdXRlQDYgbWFpbl9hZF9kZWxldGVfcm91dGVANyBtYWluX2FkX3JlYWR5X3JvdXRlQDggbWFpbl9hZF9zZWxmX2Rpc2Nsb3NlX3JvdXRlQDkgbWFpbl9hZF90ZXJtc19yb3V0ZUAxMCBtYWluX2FkX2luY29tZV9yb3V0ZUAxMSBtYWluX2FkX2FzYV9jbG9zZV9yb3V0ZUAxMiBtYWluX3RlbXBsYXRlX2xvYWRfaW5pdF9yb3V0ZUAxMyBtYWluX3RlbXBsYXRlX2xvYWRfZGF0YV9yb3V0ZUAxNCBtYWluX3RlbXBsYXRlX2xvYWRfZW5kX3JvdXRlQDE1IG1haW5fY29udHJhY3RfY3JlYXRlX3JvdXRlQDE2IG1haW5fa2V5c19jb25maXJtX3JvdXRlQDE3IG1haW5fa2V5c19ub3RfY29uZmlybWVkX3JvdXRlQDE4IG1haW5fa2V5c19ub3Rfc3VibWl0dGVkX3JvdXRlQDE5IG1haW5fa2V5c19zdWJtaXRfcm91dGVAMjAgbWFpbl9icmVhY2hfbGltaXRzX3JvdXRlQDIxIG1haW5fYnJlYWNoX3BheV9yb3V0ZUAyMiBtYWluX2JyZWFjaF9zdXNwZW5kZWRfcm91dGVAMjMgbWFpbl9jb250cmFjdF9jbGFpbV9yb3V0ZUAyNCBtYWluX2NvbnRyYWN0X2V4cGlyZWRfcm91dGVAMjUgbWFpbl9jb250cmFjdF93aXRoZHJhd19yb3V0ZUAyNiBtYWluX2NvbnRyYWN0X2RlbGV0ZV9yb3V0ZUAyNyBtYWluX2NvbnRyYWN0X3JlcG9ydF9leHBpcnlfc29vbl9yb3V0ZUAyOCBtYWluX2dhc19yb3V0ZUAyOSBtYWluX2dldF92YWxpZGF0b3JfYXNhX3JvdXRlQDMwCgptYWluX2FmdGVyX2lmX2Vsc2VAMzE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMS0xMDIKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBWYWxpZGF0b3JBZChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIGludGNfMCAvLyAwCiAgICByZXR1cm4KCm1haW5fZ2V0X3ZhbGlkYXRvcl9hc2Ffcm91dGVAMzA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1MjAtMTUyMwogICAgLy8gIyAtLS0tLSAtLS0tLSAtLS0tLSAtLS0tLS0tLS0tLS0tLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0KICAgIC8vICMgLS0tLS0gLS0tLS0gLS0tLS0gUmVhZC1vbmx5IGZ1bmN0aW9ucyAtLS0tLSAtLS0tLSAtLS0tCiAgICAvLyAjIC0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tLS0tLS0tLS0tLS0tLSAtLS0tLSAtLS0tLSAtLS0tLQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxLTEwMgogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIFZhbGlkYXRvckFkKEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTIwLTE1MjMKICAgIC8vICMgLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0tLS0tLS0tLS0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tCiAgICAvLyAjIC0tLS0tIC0tLS0tIC0tLS0tIFJlYWQtb25seSBmdW5jdGlvbnMgLS0tLS0gLS0tLS0gLS0tLQogICAgLy8gIyAtLS0tLSAtLS0tLSAtLS0tLSAtLS0tLS0tLS0tLS0tLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0KICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgY2FsbHN1YiBnZXRfdmFsaWRhdG9yX2FzYQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9nYXNfcm91dGVAMjk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1MTEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uX3JvdXRlQDI4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDcyCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMS0xMDIKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBWYWxpZGF0b3JBZChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGJ0b2kKICAgIHR4bmFzIEFwcGxpY2F0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDcyCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBjb250cmFjdF9yZXBvcnRfZXhwaXJ5X3Nvb24KICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY29udHJhY3RfZGVsZXRlX3JvdXRlQDI3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDMzCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMS0xMDIKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBWYWxpZGF0b3JBZChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIHR4bmFzIEFwcGxpY2F0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDMzCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBjb250cmFjdF9kZWxldGUKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY29udHJhY3Rfd2l0aGRyYXdfcm91dGVAMjY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEzOTYKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxLTEwMgogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIFZhbGlkYXRvckFkKEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgdHhuYXMgQXBwbGljYXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEzOTYKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGNvbnRyYWN0X3dpdGhkcmF3CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2NvbnRyYWN0X2V4cGlyZWRfcm91dGVAMjU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEzNTQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxLTEwMgogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIFZhbGlkYXRvckFkKEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYXMgQXBwbGljYXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEzNTQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGNvbnRyYWN0X2V4cGlyZWQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY29udHJhY3RfY2xhaW1fcm91dGVAMjQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEzMTcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxLTEwMgogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIFZhbGlkYXRvckFkKEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYXMgQXBwbGljYXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEzMTcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGNvbnRyYWN0X2NsYWltCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2JyZWFjaF9zdXNwZW5kZWRfcm91dGVAMjM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEyNzQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxLTEwMgogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIFZhbGlkYXRvckFkKEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYXMgQXBwbGljYXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEyNzQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGJyZWFjaF9zdXNwZW5kZWQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fYnJlYWNoX3BheV9yb3V0ZUAyMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTIzNwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDEtMTAyCiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgVmFsaWRhdG9yQWQoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG5hcyBBcHBsaWNhdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTIzNwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgYnJlYWNoX3BheQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9icmVhY2hfbGltaXRzX3JvdXRlQDIxOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMTkxCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMS0xMDIKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBWYWxpZGF0b3JBZChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmFzIEFwcGxpY2F0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMTkxCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBicmVhY2hfbGltaXRzCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2tleXNfc3VibWl0X3JvdXRlQDIwOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMTQyCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMS0xMDIKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBWYWxpZGF0b3JBZChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIHR4bmFzIEFwcGxpY2F0aW9ucwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMTQyCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBrZXlzX3N1Ym1pdAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9rZXlzX25vdF9zdWJtaXR0ZWRfcm91dGVAMTk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjExMDMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxLTEwMgogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIFZhbGlkYXRvckFkKEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYXMgQXBwbGljYXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjExMDMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGtleXNfbm90X3N1Ym1pdHRlZAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9rZXlzX25vdF9jb25maXJtZWRfcm91dGVAMTg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwNjQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxLTEwMgogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIFZhbGlkYXRvckFkKEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYXMgQXBwbGljYXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwNjQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGtleXNfbm90X2NvbmZpcm1lZAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9rZXlzX2NvbmZpcm1fcm91dGVAMTc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMzMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxLTEwMgogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIFZhbGlkYXRvckFkKEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgdHhuYXMgQXBwbGljYXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMzMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGtleXNfY29uZmlybQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9jb250cmFjdF9jcmVhdGVfcm91dGVAMTY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojg0NQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDEtMTAyCiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgVmFsaWRhdG9yQWQoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA2CiAgICB0eG4gR3JvdXBJbmRleAogICAgcHVzaGludCAyIC8vIDIKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo4NDUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGNvbnRyYWN0X2NyZWF0ZQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl90ZW1wbGF0ZV9sb2FkX2VuZF9yb3V0ZUAxNToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6ODE4CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMS0xMDIKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBWYWxpZGF0b3JBZChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6ODE4CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiB0ZW1wbGF0ZV9sb2FkX2VuZAogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl90ZW1wbGF0ZV9sb2FkX2RhdGFfcm91dGVAMTQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojc4OQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDEtMTAyCiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgVmFsaWRhdG9yQWQoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBleHRyYWN0IDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3ODkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIHRlbXBsYXRlX2xvYWRfZGF0YQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl90ZW1wbGF0ZV9sb2FkX2luaXRfcm91dGVAMTM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojc0OQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDEtMTAyCiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgVmFsaWRhdG9yQWQoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBidG9pCiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NzQ5CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiB0ZW1wbGF0ZV9sb2FkX2luaXQKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fYWRfYXNhX2Nsb3NlX3JvdXRlQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3MTAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxLTEwMgogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIFZhbGlkYXRvckFkKEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3MTAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGFkX2FzYV9jbG9zZQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9hZF9pbmNvbWVfcm91dGVAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjY2NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDEtMTAyCiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgVmFsaWRhdG9yQWQoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjY2NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgYWRfaW5jb21lCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2FkX3Rlcm1zX3JvdXRlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo1ODAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxLTEwMgogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIFZhbGlkYXRvckFkKEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNwogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjU4MAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgYWRfdGVybXMKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fYWRfc2VsZl9kaXNjbG9zZV9yb3V0ZUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo1NTYKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxLTEwMgogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIFZhbGlkYXRvckFkKEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo1NTYKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGFkX3NlbGZfZGlzY2xvc2UKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fYWRfcmVhZHlfcm91dGVAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTI0CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMS0xMDIKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBWYWxpZGF0b3JBZChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTI0CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBhZF9yZWFkeQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9hZF9kZWxldGVfcm91dGVANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDg3CiAgICAvLyBAYXJjNC5hYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIkRlbGV0ZUFwcGxpY2F0aW9uIl0pCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICBwdXNoaW50IDUgLy8gRGVsZXRlQXBwbGljYXRpb24KICAgID09CiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBEZWxldGVBcHBsaWNhdGlvbgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMS0xMDIKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBWYWxpZGF0b3JBZChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDg3CiAgICAvLyBAYXJjNC5hYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIkRlbGV0ZUFwcGxpY2F0aW9uIl0pCiAgICBjYWxsc3ViIGFkX2RlbGV0ZQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9hZF9jb25maWdfcm91dGVANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDQyCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMS0xMDIKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBWYWxpZGF0b3JBZChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDQyCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBhZF9jb25maWcKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fYWRfY3JlYXRlX3JvdXRlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQxMQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGNyZWF0ZT0icmVxdWlyZSIpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgIQogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDEtMTAyCiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgVmFsaWRhdG9yQWQoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQxMQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGNyZWF0ZT0icmVxdWlyZSIpCiAgICBjYWxsc3ViIGFkX2NyZWF0ZQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQuYWRfY3JlYXRlKHZhbF9vd25lcjogYnl0ZXMpIC0+IGJ5dGVzOgphZF9jcmVhdGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQxMS00MTUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChjcmVhdGU9InJlcXVpcmUiKQogICAgLy8gZGVmIGFkX2NyZWF0ZSgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIHZhbF9vd25lcjogYXJjNC5BZGRyZXNzLAogICAgLy8gKSAtPiBhcmM0LlVJbnQ2NDoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo0MzItNDMzCiAgICAvLyAjIFNldCBnbG9iYWwgdmFyaWFibGVzCiAgICAvLyBzZWxmLm5vdGljZWJvYXJkX2FwcF9pZCA9IEdsb2JhbC5jYWxsZXJfYXBwbGljYXRpb25faWQKICAgIGJ5dGVjIDE0IC8vICJub3RpY2Vib2FyZF9hcHBfaWQiCiAgICBnbG9iYWwgQ2FsbGVyQXBwbGljYXRpb25JRAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDM1CiAgICAvLyBzZWxmLnZhbF9vd25lciA9IHZhbF9vd25lci5uYXRpdmUKICAgIGJ5dGVjXzIgLy8gInZhbF9vd25lciIKICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDM3LTQzOAogICAgLy8gIyBDaGFuZ2Ugc3RhdGUgdG8gQ1JFQVRFRAogICAgLy8gc2VsZi5zdGF0ZSA9IEJ5dGVzKFNUQVRFX0NSRUFURUQpCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGJ5dGVjIDIwIC8vIDB4MDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ0MAogICAgLy8gcmV0dXJuIGFyYzQuVUludDY0KEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkLmlkKQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICBpdG9iCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLmFkX2NvbmZpZyh2YWxfb3duZXI6IGJ5dGVzLCB2YWxfbWFuYWdlcjogYnl0ZXMsIGxpdmU6IGJ5dGVzLCBjbnRfZGVsX21heDogdWludDY0KSAtPiB2b2lkOgphZF9jb25maWc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ0Mi00NDkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgYWRfY29uZmlnKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgdmFsX293bmVyOiBhcmM0LkFkZHJlc3MsCiAgICAvLyAgICAgdmFsX21hbmFnZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICBsaXZlIDogYXJjNC5Cb29sLAogICAgLy8gICAgIGNudF9kZWxfbWF4IDogVUludDY0LAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gNCAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ2NwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ2OQogICAgLy8gc2VsZi5zdGF0ZSAhPSBCeXRlcyhTVEFURV9DUkVBVEVEKSBhbmQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDIwIC8vIDB4MDEKICAgICE9CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ2OS00NzEKICAgIC8vIHNlbGYuc3RhdGUgIT0gQnl0ZXMoU1RBVEVfQ1JFQVRFRCkgYW5kCiAgICAvLyBzZWxmLnN0YXRlICE9IEJ5dGVzKFNUQVRFX1RFTVBMQVRFX0xPQUQpIGFuZAogICAgLy8gc2VsZi5zdGF0ZSAhPSBCeXRlcyhTVEFURV9URU1QTEFURV9MT0FERUQpCiAgICBieiBhZF9jb25maWdfYm9vbF9mYWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ3MAogICAgLy8gc2VsZi5zdGF0ZSAhPSBCeXRlcyhTVEFURV9URU1QTEFURV9MT0FEKSBhbmQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDEyIC8vIDB4MDIKICAgICE9CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ2OS00NzEKICAgIC8vIHNlbGYuc3RhdGUgIT0gQnl0ZXMoU1RBVEVfQ1JFQVRFRCkgYW5kCiAgICAvLyBzZWxmLnN0YXRlICE9IEJ5dGVzKFNUQVRFX1RFTVBMQVRFX0xPQUQpIGFuZAogICAgLy8gc2VsZi5zdGF0ZSAhPSBCeXRlcyhTVEFURV9URU1QTEFURV9MT0FERUQpCiAgICBieiBhZF9jb25maWdfYm9vbF9mYWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ3MQogICAgLy8gc2VsZi5zdGF0ZSAhPSBCeXRlcyhTVEFURV9URU1QTEFURV9MT0FERUQpCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlYyAyMSAvLyAweDAzCiAgICAhPQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo0NjktNDcxCiAgICAvLyBzZWxmLnN0YXRlICE9IEJ5dGVzKFNUQVRFX0NSRUFURUQpIGFuZAogICAgLy8gc2VsZi5zdGF0ZSAhPSBCeXRlcyhTVEFURV9URU1QTEFURV9MT0FEKSBhbmQKICAgIC8vIHNlbGYuc3RhdGUgIT0gQnl0ZXMoU1RBVEVfVEVNUExBVEVfTE9BREVEKQogICAgYnogYWRfY29uZmlnX2Jvb2xfZmFsc2VANAogICAgaW50Y18xIC8vIDEKCmFkX2NvbmZpZ19ib29sX21lcmdlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ2OC00NzIKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgc2VsZi5zdGF0ZSAhPSBCeXRlcyhTVEFURV9DUkVBVEVEKSBhbmQKICAgIC8vICAgICBzZWxmLnN0YXRlICE9IEJ5dGVzKFNUQVRFX1RFTVBMQVRFX0xPQUQpIGFuZAogICAgLy8gICAgIHNlbGYuc3RhdGUgIT0gQnl0ZXMoU1RBVEVfVEVNUExBVEVfTE9BREVEKQogICAgLy8gKSwgRVJST1JfQ0FMTEVEX0ZST01fU1RBVEVfQ1JFQVRFRF9URU1QTEFURV9MT0FEX09SX1RFTVBMQVRFX0xPQURFRAogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBzdGF0ZSBDUkVBVEVELCBURU1QTEFURV9MT0FEIG9yIFRFTVBMQVRFX0xPQURFRC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDczCiAgICAvLyBhc3NlcnQgdmFsX293bmVyLm5hdGl2ZSA9PSBzZWxmLnZhbF9vd25lciwgRVJST1JfQ0FMTEVEX0JZX05PVF9WQUxfT1dORVIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJ2YWxfb3duZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudmFsX293bmVyIGV4aXN0cwogICAgZnJhbWVfZGlnIC00CiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSB2YWxpZGF0b3Igb3duZXIuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ3NQogICAgLy8gc2VsZi52YWxfbWFuYWdlciA9IHZhbF9tYW5hZ2VyLm5hdGl2ZQogICAgYnl0ZWMgMTEgLy8gInZhbF9tYW5hZ2VyIgogICAgZnJhbWVfZGlnIC0zCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo0NzcKICAgIC8vIGFzc2VydCBjbnRfZGVsX21heCA8PSBVSW50NjQoTUFYSU1VTV9OVU1CRVJfT0ZfREVMRUdBVE9SX0NPTlRSQUNUU19QRVJfVkFMSURBVE9SX0FEKSwgRVJST1JfTk9fTUVNT1JZX0ZPUl9NT1JFX0RFTEVHQVRPUlMgICMgbm9xYTogRTUwMQogICAgZnJhbWVfZGlnIC0xCiAgICBwdXNoaW50IDE0IC8vIDE0CiAgICA8PQogICAgYXNzZXJ0IC8vIFZhbGlkYXRvciBhZCBkb2VzIG5vdCBoYXZlIGVub3VnaCBtZW1vcnkgdG8gc3RvcmUgdGhhdCBtYW55IGFjdGl2ZSBkZWxlZ2F0b3JzLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo0NzgKICAgIC8vIHNlbGYuY250X2RlbF9tYXggPSBjbnRfZGVsX21heAogICAgYnl0ZWMgMTcgLy8gImNudF9kZWxfbWF4IgogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo0ODAKICAgIC8vIGlmIGxpdmUubmF0aXZlOgogICAgZnJhbWVfZGlnIC0yCiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBieiBhZF9jb25maWdfZWxzZV9ib2R5QDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDgxCiAgICAvLyBzZWxmLnN0YXRlID0gQnl0ZXMoU1RBVEVfTk9UX1JFQURZKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBieXRlYyAyMiAvLyAweDA2CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo0ODUKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgphZF9jb25maWdfZWxzZV9ib2R5QDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ4MwogICAgLy8gc2VsZi5zdGF0ZSA9IEJ5dGVzKFNUQVRFX05PVF9MSVZFKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBwdXNoYnl0ZXMgMHgwNwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDg1CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKYWRfY29uZmlnX2Jvb2xfZmFsc2VANDoKICAgIGludGNfMCAvLyAwCiAgICBiIGFkX2NvbmZpZ19ib29sX21lcmdlQDUKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLmFkX2RlbGV0ZSh2YWxfb3duZXI6IGJ5dGVzKSAtPiB2b2lkOgphZF9kZWxldGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ4Ny00OTEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChhbGxvd19hY3Rpb25zPVsiRGVsZXRlQXBwbGljYXRpb24iXSkKICAgIC8vIGRlZiBhZF9kZWxldGUoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICB2YWxfb3duZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo1MDMKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsIEVSUk9SX0NBTExFRF9CWV9OT1RfQ1JFQVRPUgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBzbWFydCBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo1MDQKICAgIC8vIGFzc2VydCB2YWxfb3duZXIubmF0aXZlID09IHNlbGYudmFsX293bmVyLCBFUlJPUl9DQUxMRURfQllfTk9UX1ZBTF9PV05FUgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gInZhbF9vd25lciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52YWxfb3duZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTEKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHZhbGlkYXRvciBvd25lci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTA2CiAgICAvLyBhc3NlcnQgc2VsZi5jbnRfZGVsID09IFVJbnQ2NCgwKSwgRVJST1JfREVMRVRFX0FDVElWRV9ERUxFR0FUT1JTCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNCAvLyAiY250X2RlbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jbnRfZGVsIGV4aXN0cwogICAgIQogICAgYXNzZXJ0IC8vIENhbm5vdCBkZWxldGUgdmFsaWRhdG9yIGFkIGlmIHRoZXJlIGFyZSBhY3RpdmUgZGVsZWdhdG9ycy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTA3CiAgICAvLyBhc3NlcnQgc2VsZi5jbnRfYXNhID09IFVJbnQ2NCgwKSwgRVJST1JfREVMRVRFX0FTQV9SRU1BSU4KICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA4IC8vICJjbnRfYXNhIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNudF9hc2EgZXhpc3RzCiAgICAhCiAgICBhc3NlcnQgLy8gQ2Fubm90IGRlbGV0ZSB2YWxpZGF0b3IgaWYgdGhlcmUgYXJlIEFTQXMgdGhhdCByZW1haW4uCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjUwOQogICAgLy8gYXNzZXJ0IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MuYmFsYW5jZS1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlID09IFVJbnQ2NCgwKSwgXAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC0KICAgICEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTA5LTUxMAogICAgLy8gYXNzZXJ0IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MuYmFsYW5jZS1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlID09IFVJbnQ2NCgwKSwgXAogICAgLy8gICAgIEVSUk9SX0FMR09fQVZBSUxBQkxFX0JBTEFOQ0VfTk9UX1pFUk8KICAgIGFzc2VydCAvLyBBbGdvcmFuZCBiYWxhbmNlIGlzIG5vdCB6ZXJvLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo1MTIKICAgIC8vIGFzc2VydCBzZWxmLnRlbXBsYXRlLmRlbGV0ZSgpLCBFUlJPUl9ERUxFVEVfVEVNUExBVEVfQk9YICMgU2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byByYWlzZSB0aGUgZXJyb3IgaWYgY29kZSBvawogICAgYnl0ZWNfMyAvLyAweDY0CiAgICBib3hfZGVsCiAgICBhc3NlcnQgLy8gQ2Fubm90IGRlbGV0ZSBib3ggd2l0aCBzbWFydCBjb250cmFjdCB0ZW1wbGF0ZS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTE0LTUxNQogICAgLy8gIyBDbG9zZSBhY2NvdW50IHRvIG93bmVyIHRvIHJldHVybiB0aGUgTUJSCiAgICAvLyByY3YgPSBzZWxmLnZhbF9vd25lcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gInZhbF9vd25lciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52YWxfb3duZXIgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjUxNi01MjAKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1yY3YsCiAgICAvLyAgICAgYW1vdW50PTAsCiAgICAvLyAgICAgY2xvc2VfcmVtYWluZGVyX3RvPXJjdiwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGR1cAogICAgaXR4bl9maWVsZCBDbG9zZVJlbWFpbmRlclRvCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjUxOAogICAgLy8gYW1vdW50PTAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTE2CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICBpbnRjXzEgLy8gcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTE2LTUyMAogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXJjdiwKICAgIC8vICAgICBhbW91bnQ9MCwKICAgIC8vICAgICBjbG9zZV9yZW1haW5kZXJfdG89cmN2LAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTIyCiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQuYWRfcmVhZHkodmFsX21hbmFnZXI6IGJ5dGVzLCByZWFkeTogYnl0ZXMpIC0+IHZvaWQ6CmFkX3JlYWR5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo1MjQtNTI5CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGFkX3JlYWR5KAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgdmFsX21hbmFnZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICByZWFkeTogYXJjNC5Cb29sLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjU0MQogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjU0MwogICAgLy8gc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9SRUFEWSkgb3IKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDIzIC8vIDB4MDUKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjU0My01NDQKICAgIC8vIHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfUkVBRFkpIG9yCiAgICAvLyBzZWxmLnN0YXRlID09IEJ5dGVzKFNUQVRFX05PVF9SRUFEWSkKICAgIGJueiBhZF9yZWFkeV9ib29sX3RydWVAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo1NDQKICAgIC8vIHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfTk9UX1JFQURZKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZWMgMjIgLy8gMHgwNgogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTQzLTU0NAogICAgLy8gc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9SRUFEWSkgb3IKICAgIC8vIHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfTk9UX1JFQURZKQogICAgYnogYWRfcmVhZHlfYm9vbF9mYWxzZUAzCgphZF9yZWFkeV9ib29sX3RydWVAMjoKICAgIGludGNfMSAvLyAxCgphZF9yZWFkeV9ib29sX21lcmdlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjU0Mi01NDUKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9SRUFEWSkgb3IKICAgIC8vICAgICBzZWxmLnN0YXRlID09IEJ5dGVzKFNUQVRFX05PVF9SRUFEWSkKICAgIC8vICksIEVSUk9SX05PVF9TVEFURV9SRUFEWV9PUl9OT1RfUkVBRFkKICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBSRUFEWSBvciBOT1RfUkVBRFkuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjU0NwogICAgLy8gYXNzZXJ0IHZhbF9tYW5hZ2VyLm5hdGl2ZSA9PSBzZWxmLnZhbF9tYW5hZ2VyLCBFUlJPUl9DQUxMRURfQllfTk9UX1ZBTF9NQU5BR0VSCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTEgLy8gInZhbF9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnZhbF9tYW5hZ2VyIGV4aXN0cwogICAgZnJhbWVfZGlnIC0yCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSB2YWxpZGF0b3IgbWFuYWdlci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTQ5CiAgICAvLyBpZiByZWFkeS5uYXRpdmU6CiAgICBmcmFtZV9kaWcgLTEKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIGJ6IGFkX3JlYWR5X2Vsc2VfYm9keUA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjU1MAogICAgLy8gc2VsZi5zdGF0ZSA9IEJ5dGVzKFNUQVRFX1JFQURZKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBieXRlYyAyMyAvLyAweDA1CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo1NTQKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgphZF9yZWFkeV9lbHNlX2JvZHlANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTUyCiAgICAvLyBzZWxmLnN0YXRlID0gQnl0ZXMoU1RBVEVfTk9UX1JFQURZKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBieXRlYyAyMiAvLyAweDA2CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo1NTQKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgphZF9yZWFkeV9ib29sX2ZhbHNlQDM6CiAgICBpbnRjXzAgLy8gMAogICAgYiBhZF9yZWFkeV9ib29sX21lcmdlQDQKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLmFkX3NlbGZfZGlzY2xvc2UodmFsX293bmVyOiBieXRlcywgdmFsX2luZm86IGJ5dGVzKSAtPiB2b2lkOgphZF9zZWxmX2Rpc2Nsb3NlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo1NTYtNTYxCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGFkX3NlbGZfZGlzY2xvc2UoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICB2YWxfb3duZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICB2YWxfaW5mbzogVmFsaWRhdG9yU2VsZkRpc2Nsb3N1cmUsCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTczCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTc0CiAgICAvLyBhc3NlcnQgdmFsX293bmVyLm5hdGl2ZSA9PSBzZWxmLnZhbF9vd25lciwgRVJST1JfQ0FMTEVEX0JZX05PVF9WQUxfT1dORVIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJ2YWxfb3duZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudmFsX293bmVyIGV4aXN0cwogICAgZnJhbWVfZGlnIC0yCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSB2YWxpZGF0b3Igb3duZXIuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjU3NgogICAgLy8gc2VsZi52YWxfaW5mby52YWx1ZSA9IHZhbF9pbmZvLmNvcHkoKQogICAgcHVzaGJ5dGVzICJWIgogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo1NzgKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnZhbGlkYXRvcl9hZC5jb250cmFjdC5WYWxpZGF0b3JBZC5hZF90ZXJtcyh2YWxfb3duZXI6IGJ5dGVzLCB0Y19zaGEyNTY6IGJ5dGVzLCB0ZXJtc190aW1lOiBieXRlcywgdGVybXNfcHJpY2U6IGJ5dGVzLCB0ZXJtc19zdGFrZTogYnl0ZXMsIHRlcm1zX3JlcXM6IGJ5dGVzLCB0ZXJtc193YXJuOiBieXRlcywgdHhuOiB1aW50NjQpIC0+IHZvaWQ6CmFkX3Rlcm1zOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo1ODAtNTkxCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGFkX3Rlcm1zKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgdmFsX293bmVyOiBhcmM0LkFkZHJlc3MsCiAgICAvLyAgICAgdGNfc2hhMjU2OiBTaGEyNTYsCiAgICAvLyAgICAgdGVybXNfdGltZTogVmFsaWRhdG9yVGVybXNUaW1pbmcsCiAgICAvLyAgICAgdGVybXNfcHJpY2U6IFZhbGlkYXRvclRlcm1zUHJpY2luZywKICAgIC8vICAgICB0ZXJtc19zdGFrZTogVmFsaWRhdG9yVGVybXNTdGFrZUxpbWl0cywKICAgIC8vICAgICB0ZXJtc19yZXFzOiBWYWxpZGF0b3JUZXJtc0dhdGluZywKICAgIC8vICAgICB0ZXJtc193YXJuOiBWYWxpZGF0b3JUZXJtc1dhcm5pbmdzLAogICAgLy8gICAgIHR4bjogZ3R4bi5QYXltZW50VHJhbnNhY3Rpb24sCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byA4IDAKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjYxNgogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjYxNwogICAgLy8gYXNzZXJ0IHZhbF9vd25lci5uYXRpdmUgPT0gc2VsZi52YWxfb3duZXIsIEVSUk9SX0NBTExFRF9CWV9OT1RfVkFMX09XTkVSCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAidmFsX293bmVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnZhbF9vd25lciBleGlzdHMKICAgIGZyYW1lX2RpZyAtOAogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgdmFsaWRhdG9yIG93bmVyLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2MTkKICAgIC8vIG1icl9jdXIgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjIxLTYyMgogICAgLy8gIyBTYW5pdHkgY2hlY2tzIG9uIGlucHV0IHRlcm1zCiAgICAvLyBhc3NlcnQgdGVybXNfdGltZS5yb3VuZHNfc2V0dXAubmF0aXZlICsgdGVybXNfdGltZS5yb3VuZHNfY29uZmlybS5uYXRpdmUgPCB0ZXJtc190aW1lLnJvdW5kc19kdXJhdGlvbl9taW4sIFwKICAgIGZyYW1lX2RpZyAtNgogICAgZXh0cmFjdCAxNiA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZnJhbWVfZGlnIC02CiAgICBleHRyYWN0IDAgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGZyYW1lX2RpZyAtNgogICAgZXh0cmFjdCA4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICArCiAgICBpdG9iCiAgICBkaWcgMQogICAgYjwKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjIxLTYyMwogICAgLy8gIyBTYW5pdHkgY2hlY2tzIG9uIGlucHV0IHRlcm1zCiAgICAvLyBhc3NlcnQgdGVybXNfdGltZS5yb3VuZHNfc2V0dXAubmF0aXZlICsgdGVybXNfdGltZS5yb3VuZHNfY29uZmlybS5uYXRpdmUgPCB0ZXJtc190aW1lLnJvdW5kc19kdXJhdGlvbl9taW4sIFwKICAgIC8vICAgICBFUlJPUl9URVJNU19NSU5fRFVSQVRJT05fU0VUVVBfQ09ORklSTQogICAgYXNzZXJ0IC8vIE1pbmltdW0gZGVsZWdhdGlvbiBkdXJhdGlvbiBtdXN0IGJlIGxvbmdlciB0aGUgc3VtIG9mIHNldHVwIGFuZCBjb25maXJtYXRpb24gcm91bmRzLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2MjQKICAgIC8vIGFzc2VydCB0ZXJtc190aW1lLnJvdW5kc19kdXJhdGlvbl9taW4gPD0gdGVybXNfdGltZS5yb3VuZHNfZHVyYXRpb25fbWF4LCBcCiAgICBmcmFtZV9kaWcgLTYKICAgIGV4dHJhY3QgMjQgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGI8PQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2MjQtNjI1CiAgICAvLyBhc3NlcnQgdGVybXNfdGltZS5yb3VuZHNfZHVyYXRpb25fbWluIDw9IHRlcm1zX3RpbWUucm91bmRzX2R1cmF0aW9uX21heCwgXAogICAgLy8gICAgIEVSUk9SX1RFUk1fRFVSQVRJT05fTUlOX0xBUkdFUl9USEFOX01BWAogICAgYXNzZXJ0IC8vIE1pbmltdW0gZGVsZWdhdGlvbiBkdXJhdGlvbiBjYW5ub3QgYmUgbGFyZ2VyIHRoYW4gbWF4aW11bSBkdXJhdGlvbi4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjI2CiAgICAvLyBhc3NlcnQgdGVybXNfc3Rha2Uuc3Rha2VfZ3JhdGlzIDw9IFVJbnQ2NChTVEFLRV9HUkFUSVNfTUFYKSwgRVJST1JfVEVSTV9HUkFUSVNfTUFYCiAgICBmcmFtZV9kaWcgLTQKICAgIGV4dHJhY3QgOCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgaW50Y18zIC8vIDEwMDAwMDAKICAgIGl0b2IKICAgIGI8PQogICAgYXNzZXJ0IC8vIFZhbGlkYXRvciBhZCBncmF0aXMgc3Rha2UgYW1vdW50IG11c3QgYmUgYXQgc21hbGxlciBvciBlcXVhbCB0byB0aGUgbWF4aW11bSBwb3NzaWJsZS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjI3CiAgICAvLyBhc3NlcnQgdGVybXNfdGltZS5yb3VuZF9tYXhfZW5kID4gR2xvYmFsLnJvdW5kLCBFUlJPUl9BRF9FTkRfSVNfSU5fUEFTVAogICAgZnJhbWVfZGlnIC02CiAgICBleHRyYWN0IDMyIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBnbG9iYWwgUm91bmQKICAgIGl0b2IKICAgIGI+CiAgICBhc3NlcnQgLy8gVmFsaWRhdG9yIGFkIGVuZCB0aW1lIGRlZmluZWQgaXMgaW4gdGhlIHBhc3QuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjYyOQogICAgLy8gc2VsZi50Y19zaGEyNTYgPSB0Y19zaGEyNTYuY29weSgpCiAgICBieXRlYyAxNSAvLyAidGNfc2hhMjU2IgogICAgZnJhbWVfZGlnIC03CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2MzAKICAgIC8vIHNlbGYudGVybXNfdGltZS52YWx1ZSA9IHRlcm1zX3RpbWUuY29weSgpCiAgICBieXRlYyA2IC8vICJUIgogICAgZnJhbWVfZGlnIC02CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2MzEKICAgIC8vIHNlbGYudGVybXNfcHJpY2UudmFsdWUgPSB0ZXJtc19wcmljZS5jb3B5KCkKICAgIGJ5dGVjIDcgLy8gIlAiCiAgICBmcmFtZV9kaWcgLTUKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjYzMgogICAgLy8gc2VsZi50ZXJtc19zdGFrZS52YWx1ZSA9IHRlcm1zX3N0YWtlLmNvcHkoKQogICAgYnl0ZWMgOSAvLyAiUyIKICAgIGZyYW1lX2RpZyAtNAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjMzCiAgICAvLyBzZWxmLnRlcm1zX3JlcXMudmFsdWUgPSB0ZXJtc19yZXFzLmNvcHkoKQogICAgYnl0ZWMgMTYgLy8gIkciCiAgICBmcmFtZV9kaWcgLTMKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjYzNAogICAgLy8gc2VsZi50ZXJtc193YXJuLnZhbHVlID0gdGVybXNfd2Fybi5jb3B5KCkKICAgIGJ5dGVjIDEwIC8vICJXIgogICAgZnJhbWVfZGlnIC0yCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2MzYKICAgIC8vIGFzc2V0X2lkID0gdGVybXNfcHJpY2UuZmVlX2Fzc2V0X2lkLm5hdGl2ZQogICAgZnJhbWVfZGlnIC01CiAgICBleHRyYWN0IDMyIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjM3CiAgICAvLyBpZiBhc3NldF9pZCAhPSBVSW50NjQoQUxHT19BU0FfSUQpOgogICAgYnogYWRfdGVybXNfYWZ0ZXJfaWZfZWxzZUA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjYzOQogICAgLy8gaWYgYXNzZXQgbm90IGluIHNlbGYuYXNhczoKICAgIGZyYW1lX2RpZyAyCiAgICBpdG9iCiAgICBieXRlYyAxMyAvLyAweDYxNzM2MTVmCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgZnJhbWVfYnVyeSAwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGJueiBhZF90ZXJtc19hZnRlcl9pZl9lbHNlQDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjQwLTY0NQogICAgLy8gIyBPcHQgaW4gdG8gdGhlIGFzc2V0CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2NDMKICAgIC8vIGFzc2V0X3JlY2VpdmVyPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2NDQKICAgIC8vIGFzc2V0X2Ftb3VudD0wLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZnJhbWVfZGlnIDIKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjY0MC02NDEKICAgIC8vICMgT3B0IGluIHRvIHRoZSBhc3NldAogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgcHVzaGludCA0IC8vIGF4ZmVyCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjQwLTY0NQogICAgLy8gIyBPcHQgaW4gdG8gdGhlIGFzc2V0CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjQ3LTY1MQogICAgLy8gIyBDcmVhdGUgdGhlIGVudHJ5CiAgICAvLyBzZWxmLmFzYXNbYXNzZXRdID0gVmFsaWRhdG9yQVNBKAogICAgLy8gICAgIHRvdGFsX2Vhcm5pbmc9YXJjNC5VSW50NjQoMCksCiAgICAvLyAgICAgdG90YWxfZmVlc19nZW5lcmF0ZWQ9YXJjNC5VSW50NjQoMCksCiAgICAvLyApCiAgICBmcmFtZV9kaWcgMAogICAgcHVzaGJ5dGVzIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjUzCiAgICAvLyBzZWxmLmNudF9hc2EgKz0gMQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDggLy8gImNudF9hc2EiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuY250X2FzYSBleGlzdHMKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBieXRlYyA4IC8vICJjbnRfYXNhIgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKCmFkX3Rlcm1zX2FmdGVyX2lmX2Vsc2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjU1LTY1NgogICAgLy8gIyBDaGVjayBpZiBwYXltZW50IGZvciBpbmNyZWFzZSBvZiBNQlIgd2FzIG1hZGUKICAgIC8vIGFzc2VydCB0eG4ucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywgRVJST1JfUkVDRUlWRVIKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIG11c3QgYmUgdG8gdGhpcyBjb250cmFjdC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjU3CiAgICAvLyBtYnJfbmV3ID0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjY1OAogICAgLy8gbWJyX3BheV9hbW91bnQgPSBtYnJfbmV3IC0gbWJyX2N1cgogICAgZnJhbWVfZGlnIDEKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjU5CiAgICAvLyBhc3NlcnQgdHhuLmFtb3VudCA9PSBtYnJfcGF5X2Ftb3VudCwgRVJST1JfQURfVEVSTVNfTUJSCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgPT0KICAgIGFzc2VydCAvLyBJbnN1ZmZpY2llbnQgcGF5bWVudCBmb3IgTUJSIGluY3JlYXNlIG9mIHZhbGlkYXRvciBhZCBkdWUgdG8gbmV3IHRlcm1zLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2NjIKICAgIC8vIGlmIHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfVEVNUExBVEVfTE9BREVEKToKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDIxIC8vIDB4MDMKICAgID09CiAgICBieiBhZF90ZXJtc19hZnRlcl9pZl9lbHNlQDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjYzCiAgICAvLyBzZWxmLnN0YXRlID0gQnl0ZXMoU1RBVEVfU0VUKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBwdXNoYnl0ZXMgMHgwNAogICAgYXBwX2dsb2JhbF9wdXQKCmFkX3Rlcm1zX2FmdGVyX2lmX2Vsc2VANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjY1CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQuYWRfaW5jb21lKHZhbF9vd25lcjogYnl0ZXMsIGFzc2V0X2lkOiB1aW50NjQpIC0+IGJ5dGVzOgphZF9pbmNvbWU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjY2Ny02NzIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgYWRfaW5jb21lKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgdmFsX293bmVyOiBhcmM0LkFkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRfaWQ6IFVJbnQ2NCwKICAgIC8vICkgLT4gYXJjNC5VSW50NjQ6CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjkwCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjkxCiAgICAvLyBhc3NlcnQgdmFsX293bmVyLm5hdGl2ZSA9PSBzZWxmLnZhbF9vd25lciwgRVJST1JfQ0FMTEVEX0JZX05PVF9WQUxfT1dORVIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJ2YWxfb3duZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudmFsX293bmVyIGV4aXN0cwogICAgZnJhbWVfZGlnIC0yCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSB2YWxpZGF0b3Igb3duZXIuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjY5NAogICAgLy8gaWYgYXNzZXQuaWQgIT0gVUludDY0KEFMR09fQVNBX0lEKToKICAgIGZyYW1lX2RpZyAtMQogICAgYnogYWRfaW5jb21lX2Vsc2VfYm9keUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjY5NQogICAgLy8gYmFsID0gYXNzZXQuYmFsYW5jZShHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzKQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGZyYW1lX2RpZyAtMQogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBzd2FwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYXNzZXJ0IC8vIGFjY291bnQgb3B0ZWQgaW50byBhc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2OTYtNzAwCiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj12YWxfb3duZXIubmF0aXZlLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD1iYWwsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2OTYKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIHB1c2hpbnQgNCAvLyBheGZlcgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjY5Ni03MDAKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPXZhbF9vd25lci5uYXRpdmUsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PWJhbCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CgphZF9pbmNvbWVfYWZ0ZXJfaWZfZWxzZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3MDgKICAgIC8vIHJldHVybiBhcmM0LlVJbnQ2NChiYWwpCiAgICBpdG9iCiAgICByZXRzdWIKCmFkX2luY29tZV9lbHNlX2JvZHlAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NzAyCiAgICAvLyBiYWwgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLmJhbGFuY2UgLSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RCYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjcwMy03MDYKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj12YWxfb3duZXIubmF0aXZlLAogICAgLy8gICAgIGFtb3VudD1iYWwsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgZnJhbWVfZGlnIC0yCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjcwMwogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjcwMy03MDYKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj12YWxfb3duZXIubmF0aXZlLAogICAgLy8gICAgIGFtb3VudD1iYWwsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgYiBhZF9pbmNvbWVfYWZ0ZXJfaWZfZWxzZUA1CgoKLy8gc21hcnRfY29udHJhY3RzLnZhbGlkYXRvcl9hZC5jb250cmFjdC5WYWxpZGF0b3JBZC5hZF9hc2FfY2xvc2UodmFsX293bmVyOiBieXRlcywgYXNzZXRfaWQ6IHVpbnQ2NCkgLT4gdm9pZDoKYWRfYXNhX2Nsb3NlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3MTAtNzE1CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGFkX2FzYV9jbG9zZSgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIHZhbF9vd25lcjogYXJjNC5BZGRyZXNzLAogICAgLy8gICAgIGFzc2V0X2lkOiBVSW50NjQsCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NzI4CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NzI5CiAgICAvLyBhc3NlcnQgdmFsX293bmVyLm5hdGl2ZSA9PSBzZWxmLnZhbF9vd25lciwgRVJST1JfQ0FMTEVEX0JZX05PVF9WQUxfT1dORVIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJ2YWxfb3duZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudmFsX293bmVyIGV4aXN0cwogICAgZnJhbWVfZGlnIC0yCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSB2YWxpZGF0b3Igb3duZXIuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjczMQogICAgLy8gYXNzZXJ0IHNlbGYuY250X2RlbCA9PSBVSW50NjQoMCksIEVSUk9SX0NBTk5PVF9SRU1PVkVfQVNBX1dJVEhfQUNUSVZFX0RFTEVHQVRPUlMKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA0IC8vICJjbnRfZGVsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNudF9kZWwgZXhpc3RzCiAgICAhCiAgICBhc3NlcnQgLy8gQ2Fubm90IHJlbW92ZSBBU0Egd2hpbGUgdGhlcmUgYXJlIGFjdGl2ZSBkZWxlZ2F0b3JzIGJlY2F1c2Ugb25lIGNvdWxkIGJlIHN0aWxsIHVzaW5nIGl0LgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3MzQtNzM1CiAgICAvLyAjIENoZWNrIGlmIEFTQSBpcyBldmVuIHN0b3JlZCBvbiB0aGUgVmFsaWRhdG9yQWQuIFRoaXMgaW5oZXJlbnRseSBmYWlscyBmb3IgQUxHTywgd2hpY2ggaXMgc3RvcmVkIHNlcGFyYXRlbHkuCiAgICAvLyBhc3NlcnQgYXNzZXQgaW4gc2VsZi5hc2FzLCBFUlJPUl9BU0FfTk9UX1NUT1JFRF9BVF9WQUxJREFUT1JfQUQKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgYnl0ZWMgMTMgLy8gMHg2MTczNjE1ZgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIEFTQSBpcyBub3Qgc3RvcmVkIGF0IHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NzM3CiAgICAvLyBhc3NlcnQgb3AuQm94LmRlbGV0ZShCeXRlcyhCT1hfQVNBX0tFWV9QUkVGSVgpICsgb3AuaXRvYihhc3NldF9pZCkpLCBFUlJPUl9BU0FfQk9YX05PVF9ERUxFVEVECiAgICBib3hfZGVsCiAgICBhc3NlcnQgLy8gRmFpbGVkIHRvIGRlbGV0ZSBBU0EgYm94LgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3MzgKICAgIC8vIHNlbGYuY250X2FzYSAtPSAxCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgOCAvLyAiY250X2FzYSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jbnRfYXNhIGV4aXN0cwogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGJ5dGVjIDggLy8gImNudF9hc2EiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3NDAtNzQ1CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj12YWxfb3duZXIubmF0aXZlLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD0wLAogICAgLy8gICAgIGFzc2V0X2Nsb3NlX3RvPXZhbF9vd25lci5uYXRpdmUsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgQXNzZXRDbG9zZVRvCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojc0MwogICAgLy8gYXNzZXRfYW1vdW50PTAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgZnJhbWVfZGlnIC0yCiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NzQwCiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICBwdXNoaW50IDQgLy8gYXhmZXIKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3NDAtNzQ1CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj12YWxfb3duZXIubmF0aXZlLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD0wLAogICAgLy8gICAgIGFzc2V0X2Nsb3NlX3RvPXZhbF9vd25lci5uYXRpdmUsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3NDcKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnZhbGlkYXRvcl9hZC5jb250cmFjdC5WYWxpZGF0b3JBZC50ZW1wbGF0ZV9sb2FkX2luaXQodmFsX293bmVyOiBieXRlcywgdGVtcGxhdGVfc2l6ZTogdWludDY0LCBtYnJfdHhuOiB1aW50NjQpIC0+IHZvaWQ6CnRlbXBsYXRlX2xvYWRfaW5pdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NzQ5LTc1NQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiB0ZW1wbGF0ZV9sb2FkX2luaXQoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICB2YWxfb3duZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICB0ZW1wbGF0ZV9zaXplOiBVSW50NjQsCiAgICAvLyAgICAgbWJyX3R4bjogZ3R4bi5QYXltZW50VHJhbnNhY3Rpb24sCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byAzIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NzcwCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NzcxCiAgICAvLyBhc3NlcnQgdmFsX293bmVyLm5hdGl2ZSA9PSBzZWxmLnZhbF9vd25lciwgRVJST1JfQ0FMTEVEX0JZX05PVF9WQUxfT1dORVIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJ2YWxfb3duZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudmFsX293bmVyIGV4aXN0cwogICAgZnJhbWVfZGlnIC0zCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSB2YWxpZGF0b3Igb3duZXIuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojc3MwogICAgLy8gbWJyX2N1ciA9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MubWluX2JhbGFuY2UKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3NzUKICAgIC8vIGFzc2VydCBzZWxmLnN0YXRlID09IEJ5dGVzKFNUQVRFX0NSRUFURUQpLCBFUlJPUl9OT1RfU1RBVEVfQ1JFQVRFRAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZWMgMjAgLy8gMHgwMQogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBDUkVBVEVELgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3NzcKICAgIC8vIGFzc2VydCBzZWxmLnRlbXBsYXRlLmNyZWF0ZShzaXplPXRlbXBsYXRlX3NpemUpCiAgICBieXRlY18zIC8vIDB4NjQKICAgIGZyYW1lX2RpZyAtMgogICAgYm94X2NyZWF0ZQogICAgYXNzZXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojc3OQogICAgLy8gc2VsZi5zdGF0ZSA9IEJ5dGVzKFNUQVRFX1RFTVBMQVRFX0xPQUQpCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGJ5dGVjIDEyIC8vIDB4MDIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojc4MS03ODIKICAgIC8vICMgQ2hlY2sgaWYgdGhlIGlucHV0IE1CUiBwYXltZW50IHRyYW5zYWN0aW9uIHdhcyBzdWZmaWNpZW50IGZvciBpbmNyZWFzZSB2YWxpZGF0b3IgYWQncyBNQlIKICAgIC8vIG1icl9uZXcgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NzgzCiAgICAvLyBhbXQgPSAobWJyX25ldyAtIG1icl9jdXIpCiAgICBzd2FwCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojc4NAogICAgLy8gYXNzZXJ0IG1icl90eG4ucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywgRVJST1JfUkVDRUlWRVIKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIG11c3QgYmUgdG8gdGhpcyBjb250cmFjdC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6Nzg1CiAgICAvLyBhc3NlcnQgbWJyX3R4bi5hbW91bnQgPT0gYW10LCBFUlJPUl9BTU9VTlQKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQW1vdW50CiAgICA9PQogICAgYXNzZXJ0IC8vIFNlbnQgYW1vdW50IGRvZXNuJ3QgbWF0Y2ggdGhlIGFncmVlZCBvbmUuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojc4NwogICAgLy8gcmV0dXJuCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLnRlbXBsYXRlX2xvYWRfZGF0YSh2YWxfb3duZXI6IGJ5dGVzLCBvZmZzZXQ6IHVpbnQ2NCwgZGF0YTogYnl0ZXMpIC0+IHZvaWQ6CnRlbXBsYXRlX2xvYWRfZGF0YToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6Nzg5LTc5NQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiB0ZW1wbGF0ZV9sb2FkX2RhdGEoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICB2YWxfb3duZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICBvZmZzZXQ6IFVJbnQ2NCwKICAgIC8vICAgICBkYXRhOiBCeXRlcywKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDMgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo4MDkKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsIEVSUk9SX0NBTExFRF9CWV9OT1RfQ1JFQVRPUgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBzbWFydCBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo4MTAKICAgIC8vIGFzc2VydCB2YWxfb3duZXIubmF0aXZlID09IHNlbGYudmFsX293bmVyLCBFUlJPUl9DQUxMRURfQllfTk9UX1ZBTF9PV05FUgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gInZhbF9vd25lciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52YWxfb3duZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTMKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHZhbGlkYXRvciBvd25lci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6ODEyCiAgICAvLyBhc3NlcnQgc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9URU1QTEFURV9MT0FEKSwgRVJST1JfTk9UX1NUQVRFX1RFTVBMQVRFX0xPQUQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDEyIC8vIDB4MDIKICAgID09CiAgICBhc3NlcnQgLy8gQ2Fubm90IGJlIGNhbGxlZCBmcm9tIG90aGVyIHN0YXRlIHRoYW4gVEVNUExBVEVfTE9BRC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6ODE0CiAgICAvLyBzZWxmLnRlbXBsYXRlLnJlcGxhY2Uob2Zmc2V0LCBkYXRhKQogICAgYnl0ZWNfMyAvLyAweDY0CiAgICBmcmFtZV9kaWcgLTIKICAgIGZyYW1lX2RpZyAtMQogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6ODE2CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQudGVtcGxhdGVfbG9hZF9lbmQodmFsX293bmVyOiBieXRlcykgLT4gdm9pZDoKdGVtcGxhdGVfbG9hZF9lbmQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjgxOC04MjIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgdGVtcGxhdGVfbG9hZF9lbmQoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICB2YWxfb3duZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo4MzIKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsIEVSUk9SX0NBTExFRF9CWV9OT1RfQ1JFQVRPUgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBzbWFydCBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo4MzMKICAgIC8vIGFzc2VydCB2YWxfb3duZXIubmF0aXZlID09IHNlbGYudmFsX293bmVyLCBFUlJPUl9DQUxMRURfQllfTk9UX1ZBTF9PV05FUgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gInZhbF9vd25lciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52YWxfb3duZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTEKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHZhbGlkYXRvciBvd25lci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6ODM1CiAgICAvLyBhc3NlcnQgc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9URU1QTEFURV9MT0FEKSwgRVJST1JfTk9UX1NUQVRFX1RFTVBMQVRFX0xPQUQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDEyIC8vIDB4MDIKICAgID09CiAgICBhc3NlcnQgLy8gQ2Fubm90IGJlIGNhbGxlZCBmcm9tIG90aGVyIHN0YXRlIHRoYW4gVEVNUExBVEVfTE9BRC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6ODM3CiAgICAvLyBzZWxmLnN0YXRlID0gQnl0ZXMoU1RBVEVfVEVNUExBVEVfTE9BREVEKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBieXRlYyAyMSAvLyAweDAzCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo4MzkKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnZhbGlkYXRvcl9hZC5jb250cmFjdC5WYWxpZGF0b3JBZC5jb250cmFjdF9jcmVhdGUoZGVsX21hbmFnZXI6IGJ5dGVzLCBkZWxfYmVuZWZpY2lhcnk6IGJ5dGVzLCByb3VuZHNfZHVyYXRpb246IHVpbnQ2NCwgc3Rha2VfbWF4OiB1aW50NjQsIHBhcnRuZXJfYWRkcmVzczogYnl0ZXMsIHBhcnRuZXJfY29tbWlzc2lvbnM6IGJ5dGVzLCBtYnJfdHhuOiB1aW50NjQsIHR4bjogdWludDY0KSAtPiBieXRlczoKY29udHJhY3RfY3JlYXRlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo4NDUtODU2CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGNvbnRyYWN0X2NyZWF0ZSgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGRlbF9tYW5hZ2VyOiBhcmM0LkFkZHJlc3MsCiAgICAvLyAgICAgZGVsX2JlbmVmaWNpYXJ5OiBhcmM0LkFkZHJlc3MsCiAgICAvLyAgICAgcm91bmRzX2R1cmF0aW9uOiBVSW50NjQsCiAgICAvLyAgICAgc3Rha2VfbWF4OiBVSW50NjQsCiAgICAvLyAgICAgcGFydG5lcl9hZGRyZXNzOiBhcmM0LkFkZHJlc3MsCiAgICAvLyAgICAgcGFydG5lcl9jb21taXNzaW9uczogUGFydG5lckNvbW1pc3Npb25zLAogICAgLy8gICAgIG1icl90eG46IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gICAgIHR4bjogZ3R4bi5UcmFuc2FjdGlvbiwKICAgIC8vICkgLT4gYXJjNC5VSW50NjQ6CiAgICBwcm90byA4IDEKICAgIGludGNfMCAvLyAwCiAgICBkdXBuIDIKICAgIHB1c2hieXRlcyAiIgogICAgZHVwbiAxOQogICAgaW50Y18wIC8vIDAKICAgIHB1c2hieXRlcyAiIgogICAgZHVwbiAyCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo4ODkKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsIEVSUk9SX0NBTExFRF9CWV9OT1RfQ1JFQVRPUgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBzbWFydCBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo4OTEKICAgIC8vIGFzc2VydCBzZWxmLnN0YXRlID09IEJ5dGVzKFNUQVRFX1JFQURZKSwgRVJST1JfTk9UX1NUQVRFX1JFQURZCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlYyAyMyAvLyAweDA1CiAgICA9PQogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBvdGhlciBzdGF0ZSB0aGFuIFJFQURZLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo4OTMKICAgIC8vIG1icl9jdXIgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6ODk3CiAgICAvLyBpZiBzZWxmLnRlbXBsYXRlLmxlbmd0aCA+IFVJbnQ2NCg0MDk2KToKICAgIGJ5dGVjXzMgLy8gMHg2NAogICAgYm94X2xlbgogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudGVtcGxhdGUgZXhpc3RzCiAgICBpbnRjIDQgLy8gNDA5NgogICAgPgogICAgYnogY29udHJhY3RfY3JlYXRlX2Vsc2VfYm9keUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojg5OQogICAgLy8gc2VsZi50ZW1wbGF0ZS5leHRyYWN0KFVJbnQ2NCgwKSwgVUludDY0KDQwOTYpKSwKICAgIGJ5dGVjXzMgLy8gMHg2NAogICAgaW50Y18wIC8vIDAKICAgIGludGMgNCAvLyA0MDk2CiAgICBib3hfZXh0cmFjdAogICAgZnJhbWVfYnVyeSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjkwMAogICAgLy8gc2VsZi50ZW1wbGF0ZS5leHRyYWN0KFVJbnQ2NCg0MDk2KSwgc2VsZi50ZW1wbGF0ZS5sZW5ndGggLSBVSW50NjQoNDA5NikpLAogICAgYnl0ZWNfMyAvLyAweDY0CiAgICBib3hfbGVuCiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50ZW1wbGF0ZSBleGlzdHMKICAgIGludGMgNCAvLyA0MDk2CiAgICAtCiAgICBieXRlY18zIC8vIDB4NjQKICAgIGludGMgNCAvLyA0MDk2CiAgICB1bmNvdmVyIDIKICAgIGJveF9leHRyYWN0Cgpjb250cmFjdF9jcmVhdGVfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5MDgtOTIwCiAgICAvLyBkZWxfYXBwX2lkLCB0eG5fY3JlYXRlID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBEZWxlZ2F0b3JDb250cmFjdC5jb250cmFjdF9jcmVhdGUsCiAgICAvLyAgICAgZGVsX21hbmFnZXIsCiAgICAvLyAgICAgZGVsX2JlbmVmaWNpYXJ5LAogICAgLy8gICAgIHNlbGYubm90aWNlYm9hcmRfYXBwX2lkLAogICAgLy8gICAgIGFwcHJvdmFsX3Byb2dyYW09YXBwcm92YWxfcHJvZ3JhbSwKICAgIC8vICAgICBjbGVhcl9zdGF0ZV9wcm9ncmFtPWNvbXBpbGVkLmNsZWFyX3N0YXRlX3Byb2dyYW0sCiAgICAvLyAgICAgZ2xvYmFsX251bV91aW50PWNvbXBpbGVkLmdsb2JhbF91aW50cywKICAgIC8vICAgICBnbG9iYWxfbnVtX2J5dGVzPWNvbXBpbGVkLmdsb2JhbF9ieXRlcywKICAgIC8vICAgICBsb2NhbF9udW1fdWludD1jb21waWxlZC5sb2NhbF91aW50cywKICAgIC8vICAgICBsb2NhbF9udW1fYnl0ZXM9Y29tcGlsZWQubG9jYWxfYnl0ZXMsCiAgICAvLyAgICAgZXh0cmFfcHJvZ3JhbV9wYWdlcz1jb21waWxlZC5leHRyYV9wcm9ncmFtX3BhZ2VzLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5MTIKICAgIC8vIHNlbGYubm90aWNlYm9hcmRfYXBwX2lkLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDE0IC8vICJub3RpY2Vib2FyZF9hcHBfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubm90aWNlYm9hcmRfYXBwX2lkIGV4aXN0cwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo4OTUtODk2CiAgICAvLyAjIENyZWF0ZSBhIG5ldyBkZWxlZ2F0b3IgY29udHJhY3QKICAgIC8vIGNvbXBpbGVkID0gY29tcGlsZV9jb250cmFjdChEZWxlZ2F0b3JDb250cmFjdCkKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIEV4dHJhUHJvZ3JhbVBhZ2VzCiAgICBwdXNoaW50IDkgLy8gOQogICAgaXR4bl9maWVsZCBHbG9iYWxOdW1CeXRlU2xpY2UKICAgIHB1c2hpbnQgMTIgLy8gMTIKICAgIGl0eG5fZmllbGQgR2xvYmFsTnVtVWludAogICAgcHVzaGJ5dGVzIGJhc2U2NChDNEVCUXc9PSkKICAgIGl0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW1QYWdlcwogICAgZnJhbWVfZGlnIDAKICAgIGl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtUGFnZXMKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtUGFnZXMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTA4LTkyMAogICAgLy8gZGVsX2FwcF9pZCwgdHhuX2NyZWF0ZSA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgRGVsZWdhdG9yQ29udHJhY3QuY29udHJhY3RfY3JlYXRlLAogICAgLy8gICAgIGRlbF9tYW5hZ2VyLAogICAgLy8gICAgIGRlbF9iZW5lZmljaWFyeSwKICAgIC8vICAgICBzZWxmLm5vdGljZWJvYXJkX2FwcF9pZCwKICAgIC8vICAgICBhcHByb3ZhbF9wcm9ncmFtPWFwcHJvdmFsX3Byb2dyYW0sCiAgICAvLyAgICAgY2xlYXJfc3RhdGVfcHJvZ3JhbT1jb21waWxlZC5jbGVhcl9zdGF0ZV9wcm9ncmFtLAogICAgLy8gICAgIGdsb2JhbF9udW1fdWludD1jb21waWxlZC5nbG9iYWxfdWludHMsCiAgICAvLyAgICAgZ2xvYmFsX251bV9ieXRlcz1jb21waWxlZC5nbG9iYWxfYnl0ZXMsCiAgICAvLyAgICAgbG9jYWxfbnVtX3VpbnQ9Y29tcGlsZWQubG9jYWxfdWludHMsCiAgICAvLyAgICAgbG9jYWxfbnVtX2J5dGVzPWNvbXBpbGVkLmxvY2FsX2J5dGVzLAogICAgLy8gICAgIGV4dHJhX3Byb2dyYW1fcGFnZXM9Y29tcGlsZWQuZXh0cmFfcHJvZ3JhbV9wYWdlcywKICAgIC8vICkKICAgIHB1c2hieXRlcyAweGQxYmVjY2NlIC8vIG1ldGhvZCAiY29udHJhY3RfY3JlYXRlKGFkZHJlc3MsYWRkcmVzcyx1aW50NjQpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtOAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtNwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpbnRjXzIgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjkyMQogICAgLy8gZGVsX2FwcCA9IEFwcGxpY2F0aW9uKGRlbF9hcHBfaWQubmF0aXZlKQogICAgYnRvaQogICAgZHVwCiAgICBmcmFtZV9idXJ5IDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTIzLTkyNAogICAgLy8gIyBGdW5kIHRoZSBjcmVhdGVkIGRlbGVnYXRvciBjb250cmFjdAogICAgLy8gZGVsX21icl9mdW5kID0gR2xvYmFsLm1pbl9iYWxhbmNlICsgR2xvYmFsLmFzc2V0X29wdF9pbl9taW5fYmFsYW5jZQogICAgZ2xvYmFsIE1pbkJhbGFuY2UKICAgIGdsb2JhbCBBc3NldE9wdEluTWluQmFsYW5jZQogICAgKwogICAgZHVwCiAgICBmcmFtZV9idXJ5IDEwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjkyNS05MjgKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1kZWxfYXBwLmFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50PWRlbF9tYnJfZnVuZCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTI2CiAgICAvLyByZWNlaXZlcj1kZWxfYXBwLmFkZHJlc3MsCiAgICBzd2FwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5MjUKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIGludGNfMSAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5MjUtOTI4CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9ZGVsX2FwcC5hZGRyZXNzLAogICAgLy8gICAgIGFtb3VudD1kZWxfbWJyX2Z1bmQsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5MzAtOTMxCiAgICAvLyAjIFNldHVwIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QKICAgIC8vIGFzc2VydCByb3VuZHNfZHVyYXRpb24gPj0gc2VsZi50ZXJtc190aW1lLnZhbHVlLnJvdW5kc19kdXJhdGlvbl9taW4sIEVSUk9SX0RFTEVHQVRJT05fUEVSSU9EX1RPT19TSE9SVAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDYgLy8gIlQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudGVybXNfdGltZSBleGlzdHMKICAgIGV4dHJhY3QgMTYgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGZyYW1lX2RpZyAtNgogICAgaXRvYgogICAgZHVwCiAgICBmcmFtZV9idXJ5IDIKICAgIHN3YXAKICAgIGRpZyAxCiAgICBiPD0KICAgIGFzc2VydCAvLyBUb28gc2hvcnQgZGVsZWdhdGlvbiBwZXJpb2QuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjkzMgogICAgLy8gYXNzZXJ0IHJvdW5kc19kdXJhdGlvbiA8PSBzZWxmLnRlcm1zX3RpbWUudmFsdWUucm91bmRzX2R1cmF0aW9uX21heCwgRVJST1JfREVMRUdBVElPTl9QRVJJT0RfVE9PX0xPTkcKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA2IC8vICJUIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRlcm1zX3RpbWUgZXhpc3RzCiAgICBleHRyYWN0IDI0IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBiPD0KICAgIGFzc2VydCAvLyBUb28gbG9uZyBkZWxlZ2F0aW9uIHBlcmlvZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTMzCiAgICAvLyBhc3NlcnQgR2xvYmFsLnJvdW5kICsgcm91bmRzX2R1cmF0aW9uIDw9IHNlbGYudGVybXNfdGltZS52YWx1ZS5yb3VuZF9tYXhfZW5kLCBFUlJPUl9ERUxFR0FUSU9OX0VORFNfVE9PX0xBVEUKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA2IC8vICJUIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRlcm1zX3RpbWUgZXhpc3RzCiAgICBleHRyYWN0IDMyIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBnbG9iYWwgUm91bmQKICAgIGZyYW1lX2RpZyAtNgogICAgKwogICAgaXRvYgogICAgYj49CiAgICBhc3NlcnQgLy8gRGVsZWdhdGlvbiB3b3VsZCBlbmQgYXQgYSBsYXRlciB0aW1lIHRoYW4gYWxsb3dlZCBieSB2YWxpZGF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjkzNQogICAgLy8gc3Rha2VfbWF4X3NjYWxlZF9wcmljZSA9IHN0YWtlX21heCAvLyBVSW50NjQoRlJPTV9CQVNFX1RPX01JQ1JPX01VTFRJUExJRVIpCiAgICBmcmFtZV9kaWcgLTUKICAgIGludGNfMyAvLyAxMDAwMDAwCiAgICAvCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjkzNgogICAgLy8gdG1wID0gb3AubXVsdyhzZWxmLnRlcm1zX3ByaWNlLnZhbHVlLmZlZV9yb3VuZF92YXIubmF0aXZlLCBzdGFrZV9tYXhfc2NhbGVkX3ByaWNlKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDcgLy8gIlAiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudGVybXNfcHJpY2UgZXhpc3RzCiAgICBleHRyYWN0IDE2IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBtdWx3CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjkzNwogICAgLy8gZmVlX3JvdW5kX3ZhciA9IG9wLmRpdncodG1wWzBdLCB0bXBbMV0sIFVJbnQ2NChGUk9NX01JTExJX1RPX05BTk9fTVVMVElQTElFUikpCiAgICBpbnRjXzMgLy8gMTAwMDAwMAogICAgZGl2dwogICAgZHVwCiAgICBmcmFtZV9idXJ5IDEyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjkzOQogICAgLy8gc2VsZi50ZXJtc19wcmljZS52YWx1ZS5mZWVfcm91bmRfbWluLm5hdGl2ZSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA3IC8vICJQIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRlcm1zX3ByaWNlIGV4aXN0cwogICAgZXh0cmFjdCA4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5Ojc3NwogICAgLy8gaWYgYSA8IGI6CiAgICA+CiAgICBieiBjb250cmFjdF9jcmVhdGVfZWxzZV9ib2R5QDQxCiAgICBmcmFtZV9kaWcgMTIKICAgIGZyYW1lX2J1cnkgNAoKY29udHJhY3RfY3JlYXRlX2FmdGVyX2lmX2Vsc2VANDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk0MgogICAgLy8gZmVlX3NldHVwID0gc2VsZi50ZXJtc19wcmljZS52YWx1ZS5mZWVfc2V0dXAubmF0aXZlCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNyAvLyAiUCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50ZXJtc19wcmljZSBleGlzdHMKICAgIGV4dHJhY3QgMjQgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGZyYW1lX2J1cnkgMTMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTQ0CiAgICAvLyBpZiBwYXJ0bmVyX2FkZHJlc3MgIT0gYXJjNC5BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpOgogICAgZnJhbWVfZGlnIC00CiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgICE9CiAgICBieiBjb250cmFjdF9jcmVhdGVfZWxzZV9ib2R5QDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTQ1CiAgICAvLyB0bXAgPSBvcC5tdWx3KGZlZV9yb3VuZCwgcGFydG5lcl9jb21taXNzaW9ucy5jb21taXNzaW9uX29wZXJhdGlvbmFsLm5hdGl2ZSkKICAgIGZyYW1lX2RpZyAtMwogICAgZXh0cmFjdCA4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBmcmFtZV9kaWcgNAogICAgbXVsdwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5NDYKICAgIC8vIGZlZV9yb3VuZF9wYXJ0bmVyID0gb3AuZGl2dyh0bXBbMF0sIHRtcFsxXSwgVUludDY0KE9ORV9JTl9QUE0pKQogICAgaW50Y18zIC8vIDEwMDAwMDAKICAgIGRpdncKICAgIGZyYW1lX2J1cnkgMTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTQ4CiAgICAvLyB0bXAgPSBvcC5tdWx3KGZlZV9zZXR1cCwgcGFydG5lcl9jb21taXNzaW9ucy5jb21taXNzaW9uX3NldHVwLm5hdGl2ZSkKICAgIGZyYW1lX2RpZyAtMwogICAgZXh0cmFjdCAwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBmcmFtZV9kaWcgMTMKICAgIG11bHcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTQ5CiAgICAvLyBmZWVfc2V0dXBfcGFydG5lciA9IG9wLmRpdncodG1wWzBdLCB0bXBbMV0sIFVJbnQ2NChPTkVfSU5fUFBNKSkKICAgIGludGNfMyAvLyAxMDAwMDAwCiAgICBkaXZ3Cgpjb250cmFjdF9jcmVhdGVfYWZ0ZXJfaWZfZWxzZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5NTUKICAgIC8vIGNvbW1pc3Npb24gPSBzZWxmLnRlcm1zX3ByaWNlLnZhbHVlLmNvbW1pc3Npb24sCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNyAvLyAiUCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50ZXJtc19wcmljZSBleGlzdHMKICAgIGV4dHJhY3QgMCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5NTYKICAgIC8vIGZlZV9yb3VuZCA9IGFyYzQuVUludDY0KGZlZV9yb3VuZCksCiAgICBmcmFtZV9kaWcgNAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5NTcKICAgIC8vIGZlZV9zZXR1cCA9IGFyYzQuVUludDY0KGZlZV9zZXR1cCksCiAgICBmcmFtZV9kaWcgMTMKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTU4CiAgICAvLyBmZWVfYXNzZXRfaWQgPSBzZWxmLnRlcm1zX3ByaWNlLnZhbHVlLmZlZV9hc3NldF9pZCwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA3IC8vICJQIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRlcm1zX3ByaWNlIGV4aXN0cwogICAgZXh0cmFjdCAzMiA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5NjAKICAgIC8vIGZlZV9yb3VuZF9wYXJ0bmVyID0gYXJjNC5VSW50NjQoZmVlX3JvdW5kX3BhcnRuZXIpLAogICAgZnJhbWVfZGlnIDExCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk2MQogICAgLy8gZmVlX3NldHVwX3BhcnRuZXIgPSBhcmM0LlVJbnQ2NChmZWVfc2V0dXBfcGFydG5lciksCiAgICB1bmNvdmVyIDUKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTYyCiAgICAvLyByb3VuZHNfc2V0dXAgPSBzZWxmLnRlcm1zX3RpbWUudmFsdWUucm91bmRzX3NldHVwLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDYgLy8gIlQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudGVybXNfdGltZSBleGlzdHMKICAgIGV4dHJhY3QgMCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5NjMKICAgIC8vIHJvdW5kc19jb25maXJtID0gc2VsZi50ZXJtc190aW1lLnZhbHVlLnJvdW5kc19jb25maXJtLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDYgLy8gIlQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudGVybXNfdGltZSBleGlzdHMKICAgIGV4dHJhY3QgOCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5NTQtOTY0CiAgICAvLyBkZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgPSBEZWxlZ2F0aW9uVGVybXNHZW5lcmFsKAogICAgLy8gICAgIGNvbW1pc3Npb24gPSBzZWxmLnRlcm1zX3ByaWNlLnZhbHVlLmNvbW1pc3Npb24sCiAgICAvLyAgICAgZmVlX3JvdW5kID0gYXJjNC5VSW50NjQoZmVlX3JvdW5kKSwKICAgIC8vICAgICBmZWVfc2V0dXAgPSBhcmM0LlVJbnQ2NChmZWVfc2V0dXApLAogICAgLy8gICAgIGZlZV9hc3NldF9pZCA9IHNlbGYudGVybXNfcHJpY2UudmFsdWUuZmVlX2Fzc2V0X2lkLAogICAgLy8gICAgIHBhcnRuZXJfYWRkcmVzcyA9IHBhcnRuZXJfYWRkcmVzcywKICAgIC8vICAgICBmZWVfcm91bmRfcGFydG5lciA9IGFyYzQuVUludDY0KGZlZV9yb3VuZF9wYXJ0bmVyKSwKICAgIC8vICAgICBmZWVfc2V0dXBfcGFydG5lciA9IGFyYzQuVUludDY0KGZlZV9zZXR1cF9wYXJ0bmVyKSwKICAgIC8vICAgICByb3VuZHNfc2V0dXAgPSBzZWxmLnRlcm1zX3RpbWUudmFsdWUucm91bmRzX3NldHVwLAogICAgLy8gICAgIHJvdW5kc19jb25maXJtID0gc2VsZi50ZXJtc190aW1lLnZhbHVlLnJvdW5kc19jb25maXJtLAogICAgLy8gKQogICAgdW5jb3ZlciA3CiAgICB1bmNvdmVyIDcKICAgIGNvbmNhdAogICAgdW5jb3ZlciA2CiAgICBjb25jYXQKICAgIHVuY292ZXIgNQogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTQKICAgIGNvbmNhdAogICAgdW5jb3ZlciA0CiAgICBjb25jYXQKICAgIHVuY292ZXIgMwogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTY2CiAgICAvLyBzdGFrZV9tYXhfbWF4ID0gc2VsZi50ZXJtc19zdGFrZS52YWx1ZS5zdGFrZV9tYXgubmF0aXZlCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgOSAvLyAiUyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50ZXJtc19zdGFrZSBleGlzdHMKICAgIGV4dHJhY3QgMCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgZHVwCiAgICBmcmFtZV9idXJ5IDE1CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk2NwogICAgLy8gYXNzZXJ0IHN0YWtlX21heCA8PSBzdGFrZV9tYXhfbWF4LCBFUlJPUl9SRVFVRVNURURfTUFYX1NUQUtFX1RPT19ISUdICiAgICBmcmFtZV9kaWcgLTUKICAgIGRpZyAxCiAgICA8PQogICAgYXNzZXJ0IC8vIERlbGVnYXRvciByZXF1ZXN0ZWQgYSBzdGFrZSBhYm92ZSB0aGUgbWF4aW11bSBhbGxvd2VkIGJ5IHRoZSB2YWxpZGF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk2OQogICAgLy8gdG1wID0gb3AubXVsdyhzdGFrZV9tYXgsIHNlbGYudGVybXNfc3Rha2UudmFsdWUuc3Rha2VfZ3JhdGlzLm5hdGl2ZSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA5IC8vICJTIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRlcm1zX3N0YWtlIGV4aXN0cwogICAgZXh0cmFjdCA4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBmcmFtZV9kaWcgLTUKICAgIG11bHcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTcwCiAgICAvLyBzdGFrZV9ncmF0aXNfYWJzID0gb3AuZGl2dyh0bXBbMF0sIHRtcFsxXSwgVUludDY0KFNUQUtFX0dSQVRJU19NQVgpKQogICAgaW50Y18zIC8vIDEwMDAwMDAKICAgIGRpdncKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTcxCiAgICAvLyBzdGFrZV9tYXhfd19ncmF0aXMgPSBzdGFrZV9tYXggKyBzdGFrZV9ncmF0aXNfYWJzCiAgICBmcmFtZV9kaWcgLTUKICAgICsKICAgIGR1cAogICAgZnJhbWVfYnVyeSAxNgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5NzIKICAgIC8vIGlmIHN0YWtlX21heF93X2dyYXRpcyA8IHN0YWtlX21heF9tYXg6CiAgICA+CiAgICBieiBjb250cmFjdF9jcmVhdGVfZWxzZV9ib2R5QDEwCiAgICBmcmFtZV9kaWcgMTYKCmNvbnRyYWN0X2NyZWF0ZV9hZnRlcl9pZl9lbHNlQDExOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5NzgKICAgIC8vIHN0YWtlX21heCA9IGFyYzQuVUludDY0KHN0YWtlX21heF9naXZlbiksCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk3OQogICAgLy8gY250X2JyZWFjaF9kZWxfbWF4ID0gc2VsZi50ZXJtc193YXJuLnZhbHVlLmNudF93YXJuaW5nX21heCwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMCAvLyAiVyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50ZXJtc193YXJuIGV4aXN0cwogICAgZXh0cmFjdCAwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk4MAogICAgLy8gcm91bmRzX2JyZWFjaCA9IHNlbGYudGVybXNfd2Fybi52YWx1ZS5yb3VuZHNfd2FybmluZywKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMCAvLyAiVyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50ZXJtc193YXJuIGV4aXN0cwogICAgZXh0cmFjdCA4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk4MQogICAgLy8gZ2F0aW5nX2FzYV9saXN0ID0gc2VsZi50ZXJtc19yZXFzLnZhbHVlLmdhdGluZ19hc2FfbGlzdC5jb3B5KCksCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTYgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudGVybXNfcmVxcyBleGlzdHMKICAgIGV4dHJhY3QgMCAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTc3LTk4MgogICAgLy8gZGVsZWdhdGlvbl90ZXJtc19iYWxhbmNlID0gRGVsZWdhdGlvblRlcm1zQmFsYW5jZSgKICAgIC8vICAgICBzdGFrZV9tYXggPSBhcmM0LlVJbnQ2NChzdGFrZV9tYXhfZ2l2ZW4pLAogICAgLy8gICAgIGNudF9icmVhY2hfZGVsX21heCA9IHNlbGYudGVybXNfd2Fybi52YWx1ZS5jbnRfd2FybmluZ19tYXgsCiAgICAvLyAgICAgcm91bmRzX2JyZWFjaCA9IHNlbGYudGVybXNfd2Fybi52YWx1ZS5yb3VuZHNfd2FybmluZywKICAgIC8vICAgICBnYXRpbmdfYXNhX2xpc3QgPSBzZWxmLnRlcm1zX3JlcXMudmFsdWUuZ2F0aW5nX2FzYV9saXN0LmNvcHkoKSwKICAgIC8vICkKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTg0LTk5MQogICAgLy8gYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgRGVsZWdhdG9yQ29udHJhY3QuY29udHJhY3Rfc2V0dXAsCiAgICAvLyAgICAgc2VsZi50Y19zaGEyNTYuY29weSgpLAogICAgLy8gICAgIGRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC5jb3B5KCksCiAgICAvLyAgICAgZGVsZWdhdGlvbl90ZXJtc19iYWxhbmNlLmNvcHkoKSwKICAgIC8vICAgICByb3VuZHNfZHVyYXRpb24sCiAgICAvLyAgICAgYXBwX2lkPWRlbF9hcHAuaWQsCiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk4NgogICAgLy8gc2VsZi50Y19zaGEyNTYuY29weSgpLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDE1IC8vICJ0Y19zaGEyNTYiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudGNfc2hhMjU2IGV4aXN0cwogICAgZnJhbWVfZGlnIDgKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5ODQtOTkxCiAgICAvLyBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBEZWxlZ2F0b3JDb250cmFjdC5jb250cmFjdF9zZXR1cCwKICAgIC8vICAgICBzZWxmLnRjX3NoYTI1Ni5jb3B5KCksCiAgICAvLyAgICAgZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLmNvcHkoKSwKICAgIC8vICAgICBkZWxlZ2F0aW9uX3Rlcm1zX2JhbGFuY2UuY29weSgpLAogICAgLy8gICAgIHJvdW5kc19kdXJhdGlvbiwKICAgIC8vICAgICBhcHBfaWQ9ZGVsX2FwcC5pZCwKICAgIC8vICkKICAgIHB1c2hieXRlcyAweDdkM2RiNDc0IC8vIG1ldGhvZCAiY29udHJhY3Rfc2V0dXAoYnl0ZVszMl0sKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCksKHVpbnQ2NCx1aW50NjQsdWludDY0LCh1aW50NjQsdWludDY0KVsyXSksdWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAxCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50Y18yIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTkzLTk5NAogICAgLy8gIyBDaGVjayBwYXltZW50IGFuZCBmb3J3YXJkIGl0IHRvIHRoZSBjcmVhdGVkIGRlbGVnYXRvciBjb250cmFjdAogICAgLy8gaWYgdHhuLnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLlBheW1lbnQ6CiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMTcKICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBieiBjb250cmFjdF9jcmVhdGVfZWxzZV9ib2R5QDE0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk5NQogICAgLy8gYXNzZXJ0IHR4bi5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLCBFUlJPUl9SRUNFSVZFUgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gbXVzdCBiZSB0byB0aGlzIGNvbnRyYWN0LgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5OTcKICAgIC8vIHR5cGU9VHJhbnNhY3Rpb25UeXBlLlBheW1lbnQsCiAgICBpbnRjXzEgLy8gcGF5CiAgICBmcmFtZV9idXJ5IDIyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk5OAogICAgLy8gcmVjZWl2ZXI9ZGVsX2FwcC5hZGRyZXNzLAogICAgZnJhbWVfZGlnIDgKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGludGNfMSAvLyAxCiAgICBmcmFtZV9idXJ5IDIwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk5OQogICAgLy8gYW1vdW50PXR4bi5hbW91bnQsCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgZnJhbWVfYnVyeSAyNAogICAgaW50Y18xIC8vIDEKICAgIGZyYW1lX2J1cnkgMTgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTk2CiAgICAvLyB0eG5fZm9yd2FyZCA9IGl0eG4uSW5uZXJUcmFuc2FjdGlvbigKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDIxCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAxOQogICAgaW50Y18wIC8vIDAKICAgIHN3YXAKICAgIGZyYW1lX2J1cnkgMjMKCmNvbnRyYWN0X2NyZWF0ZV9hZnRlcl9pZl9lbHNlQDE4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDEyLTEwMTcKICAgIC8vICMgUGF5IHNldHVwIGZlZSB0byB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0CiAgICAvLyBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCggICMgbm9xYTogRjg0MQogICAgLy8gICAgIERlbGVnYXRvckNvbnRyYWN0LmNvbnRyYWN0X3BheSwKICAgIC8vICAgICB0eG5fZm9yd2FyZC5jb3B5KCksCiAgICAvLyAgICAgYXBwX2lkPWRlbF9hcHAuaWQsCiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMTUKICAgIC8vIHR4bl9mb3J3YXJkLmNvcHkoKSwKICAgIGJ6IGNvbnRyYWN0X2NyZWF0ZV9uZXh0X2ZpZWxkQDIwCiAgICBmcmFtZV9kaWcgMjcKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKY29udHJhY3RfY3JlYXRlX25leHRfZmllbGRAMjA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMTUKICAgIC8vIHR4bl9mb3J3YXJkLmNvcHkoKSwKICAgIGZyYW1lX2RpZyAxOQogICAgYnogY29udHJhY3RfY3JlYXRlX25leHRfZmllbGRAMjIKICAgIGZyYW1lX2RpZyAyNgogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAoKY29udHJhY3RfY3JlYXRlX25leHRfZmllbGRAMjI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMTUKICAgIC8vIHR4bl9mb3J3YXJkLmNvcHkoKSwKICAgIGZyYW1lX2RpZyAyMQogICAgYnogY29udHJhY3RfY3JlYXRlX25leHRfZmllbGRAMjQKICAgIGZyYW1lX2RpZyAyNQogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKCmNvbnRyYWN0X2NyZWF0ZV9uZXh0X2ZpZWxkQDI0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDE1CiAgICAvLyB0eG5fZm9yd2FyZC5jb3B5KCksCiAgICBmcmFtZV9kaWcgMTgKICAgIGJ6IGNvbnRyYWN0X2NyZWF0ZV9uZXh0X2ZpZWxkQDI2CiAgICBmcmFtZV9kaWcgMjQKICAgIGl0eG5fZmllbGQgQW1vdW50Cgpjb250cmFjdF9jcmVhdGVfbmV4dF9maWVsZEAyNjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxNQogICAgLy8gdHhuX2ZvcndhcmQuY29weSgpLAogICAgZnJhbWVfZGlnIDIwCiAgICBieiBjb250cmFjdF9jcmVhdGVfbmV4dF9maWVsZEAyOAogICAgZnJhbWVfZGlnIDIzCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCgpjb250cmFjdF9jcmVhdGVfbmV4dF9maWVsZEAyODoKICAgIGZyYW1lX2RpZyAyMgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5OTYKICAgIC8vIHR4bl9mb3J3YXJkID0gaXR4bi5Jbm5lclRyYW5zYWN0aW9uKAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMTItMTAxNwogICAgLy8gIyBQYXkgc2V0dXAgZmVlIHRvIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QKICAgIC8vIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKCAgIyBub3FhOiBGODQxCiAgICAvLyAgICAgRGVsZWdhdG9yQ29udHJhY3QuY29udHJhY3RfcGF5LAogICAgLy8gICAgIHR4bl9mb3J3YXJkLmNvcHkoKSwKICAgIC8vICAgICBhcHBfaWQ9ZGVsX2FwcC5pZCwKICAgIC8vICkKICAgIGl0eG5fbmV4dAogICAgZnJhbWVfZGlnIDgKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGJ5dGVzIDB4YjQ3ZWY5ZWIgLy8gbWV0aG9kICJjb250cmFjdF9wYXkodHhuKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50Y18yIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU0NQogICAgLy8gZGVsX2FkZGVkID0gRmFsc2UKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU0NgogICAgLy8gZm9yIGRlbF9pZHggaW4gdXJhbmdlKE1BWElNVU1fTlVNQkVSX09GX0RFTEVHQVRPUl9DT05UUkFDVFNfUEVSX1ZBTElEQVRPUl9BRCk6CiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSA5Cgpjb250cmFjdF9jcmVhdGVfZm9yX2hlYWRlckAzMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU0NgogICAgLy8gZm9yIGRlbF9pZHggaW4gdXJhbmdlKE1BWElNVU1fTlVNQkVSX09GX0RFTEVHQVRPUl9DT05UUkFDVFNfUEVSX1ZBTElEQVRPUl9BRCk6CiAgICBmcmFtZV9kaWcgOQogICAgcHVzaGludCAxNCAvLyAxNAogICAgPAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDUKICAgIGZyYW1lX2RpZyA2CiAgICBmcmFtZV9idXJ5IDcKICAgIGJ6IGNvbnRyYWN0X2NyZWF0ZV9hZnRlcl9mb3JAMzcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU0NwogICAgLy8gaWYgc2VsZi5kZWxfYXBwX2xpc3RbZGVsX2lkeF0gPT0gYXJjNC5VSW50NjQoMCk6CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAiZGVsX2FwcF9saXN0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9hcHBfbGlzdCBleGlzdHMKICAgIGZyYW1lX2RpZyA5CiAgICBwdXNoaW50IDggLy8gOAogICAgKgogICAgZHVwCiAgICBmcmFtZV9idXJ5IDE0CiAgICBwdXNoaW50IDggLy8gOAogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBieXRlYyAyNCAvLyAweDAwMDAwMDAwMDAwMDAwMDAKICAgIGI9PQogICAgYnogY29udHJhY3RfY3JlYXRlX2FmdGVyX2lmX2Vsc2VAMzUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU0OAogICAgLy8gc2VsZi5kZWxfYXBwX2xpc3RbZGVsX2lkeF0gPSBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKQogICAgZnJhbWVfZGlnIDgKICAgIGl0b2IKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA1IC8vICJkZWxfYXBwX2xpc3QiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX2FwcF9saXN0IGV4aXN0cwogICAgZnJhbWVfZGlnIDUKICAgIGFzc2VydCAvLyBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZnJhbWVfZGlnIDE0CiAgICB1bmNvdmVyIDIKICAgIHJlcGxhY2UzCiAgICBieXRlYyA1IC8vICJkZWxfYXBwX2xpc3QiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTQ5CiAgICAvLyBkZWxfYWRkZWQgPSBUcnVlCiAgICBpbnRjXzEgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTUwCiAgICAvLyBzZWxmLmNudF9kZWwgKz0gMQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDQgLy8gImNudF9kZWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuY250X2RlbCBleGlzdHMKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBieXRlYyA0IC8vICJjbnRfZGVsIgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGZyYW1lX2J1cnkgNwoKY29udHJhY3RfY3JlYXRlX2FmdGVyX2ZvckAzNzoKICAgIGZyYW1lX2RpZyA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMTktMTAyMAogICAgLy8gIyBBZGQgY3JlYXRlZCBkZWxlZ2F0b3IgY29udHJhY3QgdG8gdGhlIGxpc3Qgb2YgYWN0aXZlIGRlbGVnYXRvcnMgb2YgdGhpcyB2YWxpZGF0b3IgYWQKICAgIC8vIGFzc2VydCBzZWxmLl9hZGRfZGVsX3RvX2xpc3QoZGVsX2FwcC5pZCksIEVSUk9SX0RFTEVHQVRPUl9MSVNUX0ZVTEwKICAgIGFzc2VydCAvLyBDb3VsZCBub3QgYWRkIGRlbGVnYXRvciBjb250cmFjdCB0byBkZWxlZ2F0b3IgY29udHJhY3QgbGlzdC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAyMS0xMDIyCiAgICAvLyAjIENoZWNrIGlmIHZhbGlkYXRvciBhZCBoYXMgcmVhY2hlZCBpdHMgbGltaXQgb24gbWF4aW11bSBhY2NlcHRlZCBkZWxlZ2F0b3JzCiAgICAvLyBhc3NlcnQgc2VsZi5jbnRfZGVsIDw9IHNlbGYuY250X2RlbF9tYXgsIEVSUk9SX1ZBTElEQVRPUl9GVUxMCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNCAvLyAiY250X2RlbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jbnRfZGVsIGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDE3IC8vICJjbnRfZGVsX21heCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jbnRfZGVsX21heCBleGlzdHMKICAgIDw9CiAgICBhc3NlcnQgLy8gVmFsaWRhdG9yIGFkIGhhcyByZWFjaCB0aGUgbGltaXQgb2YgbWF4aW11bSBudW1iZXIgb2YgYWN0aXZlIGRlbGVnYXRvcnMgYWNjZXB0ZWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMjQtMTAyNgogICAgLy8gIyBDaGVjayBpZiB0aGUgaW5wdXQgTUJSIHBheW1lbnQgdHJhbnNhY3Rpb24gd2FzIHN1ZmZpY2llbnQgZm9yIGluY3JlYXNlIHZhbGlkYXRvciBhZCdzIE1CUiBhbmQKICAgIC8vICMgZm9yIGZ1bmRpbmcgdGhlIGRlbGVnYXRvciBjb250cmFjdCdzIE1CUgogICAgLy8gbWJyX25ldyA9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MubWluX2JhbGFuY2UKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDI3CiAgICAvLyBhbXQgPSBkZWxfbWJyX2Z1bmQgKyAobWJyX25ldyAtIG1icl9jdXIpCiAgICBmcmFtZV9kaWcgMjgKICAgIC0KICAgIGZyYW1lX2RpZyAxMAogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDI4CiAgICAvLyBhc3NlcnQgbWJyX3R4bi5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLCBFUlJPUl9SRUNFSVZFUgogICAgZnJhbWVfZGlnIC0yCiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gbXVzdCBiZSB0byB0aGlzIGNvbnRyYWN0LgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDI5CiAgICAvLyBhc3NlcnQgbWJyX3R4bi5hbW91bnQgPT0gYW10LCBFUlJPUl9BTU9VTlQKICAgIGZyYW1lX2RpZyAtMgogICAgZ3R4bnMgQW1vdW50CiAgICA9PQogICAgYXNzZXJ0IC8vIFNlbnQgYW1vdW50IGRvZXNuJ3QgbWF0Y2ggdGhlIGFncmVlZCBvbmUuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMzEKICAgIC8vIHJldHVybiBhcmM0LlVJbnQ2NChkZWxfYXBwLmlkKQogICAgZnJhbWVfZGlnIDgKICAgIGl0b2IKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpjb250cmFjdF9jcmVhdGVfYWZ0ZXJfaWZfZWxzZUAzNToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU0NgogICAgLy8gZm9yIGRlbF9pZHggaW4gdXJhbmdlKE1BWElNVU1fTlVNQkVSX09GX0RFTEVHQVRPUl9DT05UUkFDVFNfUEVSX1ZBTElEQVRPUl9BRCk6CiAgICBmcmFtZV9kaWcgOQogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGZyYW1lX2J1cnkgOQogICAgYiBjb250cmFjdF9jcmVhdGVfZm9yX2hlYWRlckAzMgoKY29udHJhY3RfY3JlYXRlX2Vsc2VfYm9keUAxNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAwMQogICAgLy8gZWxpZiB0eG4udHlwZSA9PSBUcmFuc2FjdGlvblR5cGUuQXNzZXRUcmFuc2ZlcjoKICAgIGZyYW1lX2RpZyAxNwogICAgcHVzaGludCA0IC8vIGF4ZmVyCiAgICA9PQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIHR5cGUgbXVzdCBiZSBlaXRoZXIgUGF5bWVudCBvciBBc3NldFRyYW5zZmVyLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDAyCiAgICAvLyBhc3NlcnQgdHhuLmFzc2V0X3JlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsIEVSUk9SX1JFQ0VJVkVSCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFzc2V0UmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIG11c3QgYmUgdG8gdGhpcyBjb250cmFjdC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAwNAogICAgLy8gdHlwZT1UcmFuc2FjdGlvblR5cGUuQXNzZXRUcmFuc2ZlciwKICAgIHB1c2hpbnQgNCAvLyBheGZlcgogICAgZnJhbWVfYnVyeSAyMgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDA1CiAgICAvLyB4ZmVyX2Fzc2V0PXR4bi54ZmVyX2Fzc2V0LAogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBYZmVyQXNzZXQKICAgIGZyYW1lX2J1cnkgMjUKICAgIGludGNfMSAvLyAxCiAgICBmcmFtZV9idXJ5IDIxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMDYKICAgIC8vIGFzc2V0X3JlY2VpdmVyPWRlbF9hcHAuYWRkcmVzcywKICAgIGZyYW1lX2RpZyA4CiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBpbnRjXzEgLy8gMQogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDA3CiAgICAvLyBhc3NldF9hbW91bnQ9dHhuLmFzc2V0X2Ftb3VudCwKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQXNzZXRBbW91bnQKICAgIGZyYW1lX2J1cnkgMjYKICAgIGludGNfMSAvLyAxCiAgICBmcmFtZV9idXJ5IDE5CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMDMKICAgIC8vIHR4bl9mb3J3YXJkID0gaXR4bi5Jbm5lclRyYW5zYWN0aW9uKAogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgMjAKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDE4CiAgICBmcmFtZV9idXJ5IDI3CiAgICBiIGNvbnRyYWN0X2NyZWF0ZV9hZnRlcl9pZl9lbHNlQDE4Cgpjb250cmFjdF9jcmVhdGVfZWxzZV9ib2R5QDEwOgogICAgZnJhbWVfZGlnIDE1CiAgICBiIGNvbnRyYWN0X2NyZWF0ZV9hZnRlcl9pZl9lbHNlQDExCgpjb250cmFjdF9jcmVhdGVfZWxzZV9ib2R5QDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk1MQogICAgLy8gZmVlX3JvdW5kX3BhcnRuZXIgPSBVSW50NjQoMCkKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDExCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk1MgogICAgLy8gZmVlX3NldHVwX3BhcnRuZXIgPSBVSW50NjQoMCkKICAgIGludGNfMCAvLyAwCiAgICBiIGNvbnRyYWN0X2NyZWF0ZV9hZnRlcl9pZl9lbHNlQDgKCmNvbnRyYWN0X2NyZWF0ZV9lbHNlX2JvZHlANDE6CiAgICBmcmFtZV9kaWcgMwogICAgZnJhbWVfYnVyeSA0CiAgICBiIGNvbnRyYWN0X2NyZWF0ZV9hZnRlcl9pZl9lbHNlQDQyCgpjb250cmFjdF9jcmVhdGVfZWxzZV9ib2R5QDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjkwNAogICAgLy8gc2VsZi50ZW1wbGF0ZS5leHRyYWN0KFVJbnQ2NCgwKSwgc2VsZi50ZW1wbGF0ZS5sZW5ndGgpLAogICAgYnl0ZWNfMyAvLyAweDY0CiAgICBib3hfbGVuCiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50ZW1wbGF0ZSBleGlzdHMKICAgIGJ5dGVjXzMgLy8gMHg2NAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgYm94X2V4dHJhY3QKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5MDUKICAgIC8vIEJ5dGVzKCksCiAgICBwdXNoYnl0ZXMgMHgKICAgIGIgY29udHJhY3RfY3JlYXRlX2FmdGVyX2lmX2Vsc2VAMwoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQua2V5c19jb25maXJtKGRlbF9tYW5hZ2VyOiBieXRlcywgZGVsX2FwcDogdWludDY0KSAtPiB2b2lkOgprZXlzX2NvbmZpcm06CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMzMtMTAzOAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBrZXlzX2NvbmZpcm0oCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBkZWxfbWFuYWdlcjogYXJjNC5BZGRyZXNzLAogICAgLy8gICAgIGRlbF9hcHA6IEFwcGxpY2F0aW9uLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwNTEKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsIEVSUk9SX0NBTExFRF9CWV9OT1RfQ1JFQVRPUgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBzbWFydCBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDUzCiAgICAvLyBhc3NlcnQgc2VsZi5fZXhpc3RzX2RlbF9pbl9saXN0KGRlbF9hcHAuaWQpLCBFUlJPUl9ERUxFR0FUT1JfRE9FU19OT1RfRVhJU1RfQVRfVkFMSURBVE9SX0FECiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX2V4aXN0c19kZWxfaW5fbGlzdAogICAgYXNzZXJ0IC8vIERlbGVnYXRvciBjb250cmFjdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgbGlzdCBvZiBhY3RpdmUgZGVsZWdhdG9ycyBvZiB0aGUgdmFsaWRhdG9yIGFkLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDU1LTEwNjAKICAgIC8vICMgQ2FsbCBrZXlzX2NvbmZpcm0gb2YgdGhlIGRlbGVnYXRvciBjb250cmFjdAogICAgLy8gYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoICAjIG5vcWE6IEY4NDEKICAgIC8vICAgICBEZWxlZ2F0b3JDb250cmFjdC5rZXlzX2NvbmZpcm0sCiAgICAvLyAgICAgZGVsX21hbmFnZXIsCiAgICAvLyAgICAgYXBwX2lkPWRlbF9hcHAuaWQsCiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGJ5dGVzIDB4Y2FlYjFhN2IgLy8gbWV0aG9kICJrZXlzX2NvbmZpcm0oYWRkcmVzcyl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludGNfMiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwNjIKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnZhbGlkYXRvcl9hZC5jb250cmFjdC5WYWxpZGF0b3JBZC5rZXlzX25vdF9jb25maXJtZWQoZGVsX2FwcDogdWludDY0KSAtPiBieXRlczoKa2V5c19ub3RfY29uZmlybWVkOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDY0LTEwNjgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYga2V5c19ub3RfY29uZmlybWVkKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX2FwcDogQXBwbGljYXRpb24sCiAgICAvLyApIC0+IE1lc3NhZ2U6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTA4NQogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwODcKICAgIC8vIGFzc2VydCBzZWxmLl9leGlzdHNfZGVsX2luX2xpc3QoZGVsX2FwcC5pZCksIEVSUk9SX0RFTEVHQVRPUl9ET0VTX05PVF9FWElTVF9BVF9WQUxJREFUT1JfQUQKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfZXhpc3RzX2RlbF9pbl9saXN0CiAgICBhc3NlcnQgLy8gRGVsZWdhdG9yIGNvbnRyYWN0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBsaXN0IG9mIGFjdGl2ZSBkZWxlZ2F0b3JzIG9mIHRoZSB2YWxpZGF0b3IgYWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwODktMTA5MwogICAgLy8gIyBDYWxsIGtleXNfbm90X2NvbmZpcm1lZCBvZiB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0CiAgICAvLyByZXMsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIERlbGVnYXRvckNvbnRyYWN0LmtleXNfbm90X2NvbmZpcm1lZCwKICAgIC8vICAgICBhcHBfaWQ9ZGVsX2FwcC5pZCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBwdXNoYnl0ZXMgMHgyNjFiZDE5OSAvLyBtZXRob2QgImtleXNfbm90X2NvbmZpcm1lZCgpKGFkZHJlc3MsYnl0ZVsxMDBdKSIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpbnRjXzIgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwOTUtMTA5NgogICAgLy8gIyBSZW1vdmUgdGhlIGRlbGVnYXRvciBjb250cmFjdCBmcm9tIHRoZSBsaXN0CiAgICAvLyBhc3NlcnQgc2VsZi5fcmVtb3ZlX2RlbF9mcm9tX2xpc3QoZGVsX2FwcC5pZCksIEVSUk9SX0ZBSUxfVE9fUkVNT1ZFX0RFTEVHQVRPUl9DT05UUkFDVF9GUk9NX0xJU1QKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfcmVtb3ZlX2RlbF9mcm9tX2xpc3QKICAgIGFzc2VydCAvLyBGYWlsZWQgdG8gcmVtb3ZlIGRlbGVnYXRvciBjb250cmFjdCBmcm9tIHRoZSBsaXN0IG9mIGFjdGl2ZSBkZWxlZ2F0b3JzIG9mIHRoZSB2YWxpZGF0b3IgYWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwOTkKICAgIC8vIGRlbF9tYW5hZ2VyPXJlcy5kZWxfbWFuYWdlciwKICAgIGR1cAogICAgZXh0cmFjdCAwIDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMTAwCiAgICAvLyBtc2c9cmVzLm1zZy5jb3B5KCksCiAgICBzd2FwCiAgICBleHRyYWN0IDMyIDEwMCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTA5OC0xMTAxCiAgICAvLyByZXR1cm4gTWVzc2FnZSgKICAgIC8vICAgICBkZWxfbWFuYWdlcj1yZXMuZGVsX21hbmFnZXIsCiAgICAvLyAgICAgbXNnPXJlcy5tc2cuY29weSgpLAogICAgLy8gKQogICAgY29uY2F0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLmtleXNfbm90X3N1Ym1pdHRlZChkZWxfYXBwOiB1aW50NjQpIC0+IGJ5dGVzOgprZXlzX25vdF9zdWJtaXR0ZWQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjExMDMtMTEwNwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBrZXlzX25vdF9zdWJtaXR0ZWQoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBkZWxfYXBwOiBBcHBsaWNhdGlvbiwKICAgIC8vICkgLT4gTWVzc2FnZToKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMTI0CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTEyNgogICAgLy8gYXNzZXJ0IHNlbGYuX2V4aXN0c19kZWxfaW5fbGlzdChkZWxfYXBwLmlkKSwgRVJST1JfREVMRUdBVE9SX0RPRVNfTk9UX0VYSVNUX0FUX1ZBTElEQVRPUl9BRAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9leGlzdHNfZGVsX2luX2xpc3QKICAgIGFzc2VydCAvLyBEZWxlZ2F0b3IgY29udHJhY3QgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxpc3Qgb2YgYWN0aXZlIGRlbGVnYXRvcnMgb2YgdGhlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTEyOC0xMTMyCiAgICAvLyAjIENhbGwga2V5c19ub3Rfc3VibWl0dGVkIG9mIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QKICAgIC8vIHJlcywgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgRGVsZWdhdG9yQ29udHJhY3Qua2V5c19ub3Rfc3VibWl0dGVkLAogICAgLy8gICAgIGFwcF9pZD1kZWxfYXBwLmlkLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hieXRlcyAweGZlODExYWU3IC8vIG1ldGhvZCAia2V5c19ub3Rfc3VibWl0dGVkKCkoYWRkcmVzcyxieXRlWzEwMF0pIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludGNfMiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQVJDNCBwcmVmaXggaXMgdmFsaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTEzNC0xMTM1CiAgICAvLyAjIFJlbW92ZSB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0IGZyb20gdGhlIGxpc3QKICAgIC8vIGFzc2VydCBzZWxmLl9yZW1vdmVfZGVsX2Zyb21fbGlzdChkZWxfYXBwLmlkKSwgRVJST1JfRkFJTF9UT19SRU1PVkVfREVMRUdBVE9SX0NPTlRSQUNUX0ZST01fTElTVAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9yZW1vdmVfZGVsX2Zyb21fbGlzdAogICAgYXNzZXJ0IC8vIEZhaWxlZCB0byByZW1vdmUgZGVsZWdhdG9yIGNvbnRyYWN0IGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIGRlbGVnYXRvcnMgb2YgdGhlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTEzOAogICAgLy8gZGVsX21hbmFnZXI9cmVzLmRlbF9tYW5hZ2VyLAogICAgZHVwCiAgICBleHRyYWN0IDAgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjExMzkKICAgIC8vIG1zZz1yZXMubXNnLmNvcHkoKSwKICAgIHN3YXAKICAgIGV4dHJhY3QgMzIgMTAwIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMTM3LTExNDAKICAgIC8vIHJldHVybiBNZXNzYWdlKAogICAgLy8gICAgIGRlbF9tYW5hZ2VyPXJlcy5kZWxfbWFuYWdlciwKICAgIC8vICAgICBtc2c9cmVzLm1zZy5jb3B5KCksCiAgICAvLyApCiAgICBjb25jYXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQua2V5c19zdWJtaXQodmFsX21hbmFnZXI6IGJ5dGVzLCBkZWxfYXBwOiB1aW50NjQsIGtleV9yZWdfdHhuX2luZm86IGJ5dGVzKSAtPiBieXRlczoKa2V5c19zdWJtaXQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjExNDItMTE0OAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBrZXlzX3N1Ym1pdCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIHZhbF9tYW5hZ2VyOiBhcmM0LkFkZHJlc3MsCiAgICAvLyAgICAgZGVsX2FwcDogQXBwbGljYXRpb24sCiAgICAvLyAgICAga2V5X3JlZ190eG5faW5mbyA6IEtleVJlZ1R4bkluZm8sCiAgICAvLyApIC0+IE1lc3NhZ2U6CiAgICBwcm90byAzIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTE2OQogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjExNzEKICAgIC8vIGFzc2VydCBzZWxmLl9leGlzdHNfZGVsX2luX2xpc3QoZGVsX2FwcC5pZCksIEVSUk9SX0RFTEVHQVRPUl9ET0VTX05PVF9FWElTVF9BVF9WQUxJREFUT1JfQUQKICAgIGZyYW1lX2RpZyAtMgogICAgY2FsbHN1YiBfZXhpc3RzX2RlbF9pbl9saXN0CiAgICBhc3NlcnQgLy8gRGVsZWdhdG9yIGNvbnRyYWN0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBsaXN0IG9mIGFjdGl2ZSBkZWxlZ2F0b3JzIG9mIHRoZSB2YWxpZGF0b3IgYWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjExNzMKICAgIC8vIGFzc2VydCBzZWxmLnZhbF9tYW5hZ2VyID09IHZhbF9tYW5hZ2VyLm5hdGl2ZSwgRVJST1JfQ0FMTEVEX0JZX05PVF9WQUxfTUFOQUdFUgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDExIC8vICJ2YWxfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52YWxfbWFuYWdlciBleGlzdHMKICAgIGZyYW1lX2RpZyAtMwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgdmFsaWRhdG9yIG1hbmFnZXIuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjExNzUtMTE4MAogICAgLy8gIyBDYWxsIGtleXNfc3VibWl0IG9mIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QKICAgIC8vIHJlcywgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgRGVsZWdhdG9yQ29udHJhY3Qua2V5c19zdWJtaXQsCiAgICAvLyAgICAga2V5X3JlZ190eG5faW5mbywKICAgIC8vICAgICBhcHBfaWQ9ZGVsX2FwcC5pZCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBwdXNoYnl0ZXMgMHgxZjMzOTlhOCAvLyBtZXRob2QgImtleXNfc3VibWl0KCh1aW50NjQsdWludDY0LHVpbnQ2NCxieXRlWzMyXSxieXRlWzMyXSxieXRlWzY0XSxhZGRyZXNzKSkoKHVpbnQ2NCx1aW50NjQsdWludDY0KSxhZGRyZXNzLGJ5dGVbMTAwXSkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50Y18yIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBBUkM0IHByZWZpeCBpcyB2YWxpZAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMTgxCiAgICAvLyBlYXJuaW5nc19kaXN0cmlidXRpb24gPSByZXMuZWFybmluZ3NfZGlzdHJpYnV0aW9uLmNvcHkoKQogICAgZHVwCiAgICBleHRyYWN0IDAgMjQgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjExODMtMTE4NAogICAgLy8gIyBNYXJrIGluY3JlYXNlIGluIHZhbGlkYXRvcidzIGVhcm5pbmdzCiAgICAvLyBzZWxmLl9tYXJrX3ZhbGlkYXRvcl9lYXJuaW5ncyhlYXJuaW5nc19kaXN0cmlidXRpb24uY29weSgpKQogICAgY2FsbHN1YiBfbWFya192YWxpZGF0b3JfZWFybmluZ3MKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMTg3CiAgICAvLyBkZWxfbWFuYWdlcj1yZXMuZGVsX21hbmFnZXIsCiAgICBkdXAKICAgIGV4dHJhY3QgMjQgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjExODgKICAgIC8vIG1zZz1yZXMubXNnLmNvcHkoKSwKICAgIHN3YXAKICAgIGV4dHJhY3QgNTYgMTAwIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMTg2LTExODkKICAgIC8vIHJldHVybiBNZXNzYWdlKAogICAgLy8gICAgIGRlbF9tYW5hZ2VyPXJlcy5kZWxfbWFuYWdlciwKICAgIC8vICAgICBtc2c9cmVzLm1zZy5jb3B5KCksCiAgICAvLyApCiAgICBjb25jYXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQuYnJlYWNoX2xpbWl0cyhkZWxfYXBwOiB1aW50NjQpIC0+IGJ5dGVzOgpicmVhY2hfbGltaXRzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMTkxLTExOTUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgYnJlYWNoX2xpbWl0cygKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGRlbF9hcHA6IEFwcGxpY2F0aW9uLAogICAgLy8gKSAtPiBCcmVhY2hMaW1pdHNSZXR1cm46CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTIxOAogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEyMjAKICAgIC8vIGFzc2VydCBzZWxmLl9leGlzdHNfZGVsX2luX2xpc3QoZGVsX2FwcC5pZCksIEVSUk9SX0RFTEVHQVRPUl9ET0VTX05PVF9FWElTVF9BVF9WQUxJREFUT1JfQUQKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfZXhpc3RzX2RlbF9pbl9saXN0CiAgICBhc3NlcnQgLy8gRGVsZWdhdG9yIGNvbnRyYWN0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBsaXN0IG9mIGFjdGl2ZSBkZWxlZ2F0b3JzIG9mIHRoZSB2YWxpZGF0b3IgYWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEyMjItMTIyNgogICAgLy8gIyBDYWxsIGJyZWFjaF9saW1pdHMgb2YgdGhlIGRlbGVnYXRvciBjb250cmFjdAogICAgLy8gcmVzLCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBEZWxlZ2F0b3JDb250cmFjdC5icmVhY2hfbGltaXRzLAogICAgLy8gICAgIGFwcF9pZD1kZWxfYXBwLmlkLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hieXRlcyAweGMxNzczZWUwIC8vIG1ldGhvZCAiYnJlYWNoX2xpbWl0cygpKGJvb2wsKHVpbnQ2NCx1aW50NjQsdWludDY0KSxhZGRyZXNzLGJ5dGVbMTAwXSkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50Y18yIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQVJDNCBwcmVmaXggaXMgdmFsaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTIyOC0xMjI5CiAgICAvLyAjIE1hcmsgaW5jcmVhc2UgaW4gdmFsaWRhdG9yJ3MgZWFybmluZ3MKICAgIC8vIHNlbGYuX21hcmtfdmFsaWRhdG9yX2Vhcm5pbmdzKHJlcy5lYXJuaW5nc19kaXN0cmlidXRpb24uY29weSgpKQogICAgZHVwCiAgICBleHRyYWN0IDEgMjQgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBjYWxsc3ViIF9tYXJrX3ZhbGlkYXRvcl9lYXJuaW5ncwogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEyMzEKICAgIC8vIGlmIHJlcy5tYXhfYnJlYWNoX3JlYWNoZWQubmF0aXZlOgogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgcHVzaGJ5dGVzIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgYnogYnJlYWNoX2xpbWl0c19hZnRlcl9pZl9lbHNlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTIzMi0xMjMzCiAgICAvLyAjIFJlbW92ZSB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0IGZyb20gdGhlIGxpc3QKICAgIC8vIGFzc2VydCBzZWxmLl9yZW1vdmVfZGVsX2Zyb21fbGlzdChkZWxfYXBwLmlkKSwgRVJST1JfRkFJTF9UT19SRU1PVkVfREVMRUdBVE9SX0NPTlRSQUNUX0ZST01fTElTVAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9yZW1vdmVfZGVsX2Zyb21fbGlzdAogICAgYXNzZXJ0IC8vIEZhaWxlZCB0byByZW1vdmUgZGVsZWdhdG9yIGNvbnRyYWN0IGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIGRlbGVnYXRvcnMgb2YgdGhlIHZhbGlkYXRvciBhZC4KCmJyZWFjaF9saW1pdHNfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMjM1CiAgICAvLyByZXR1cm4gcmVzLmNvcHkoKQogICAgZnJhbWVfZGlnIDAKICAgIHN3YXAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQuYnJlYWNoX3BheShkZWxfYXBwOiB1aW50NjQpIC0+IGJ5dGVzOgpicmVhY2hfcGF5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMjM3LTEyNDEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgYnJlYWNoX3BheSgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGRlbF9hcHA6IEFwcGxpY2F0aW9uLAogICAgLy8gKSAtPiBNZXNzYWdlOgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEyNTkKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsIEVSUk9SX0NBTExFRF9CWV9OT1RfQ1JFQVRPUgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBzbWFydCBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMjYxCiAgICAvLyBhc3NlcnQgc2VsZi5fZXhpc3RzX2RlbF9pbl9saXN0KGRlbF9hcHAuaWQpLCBFUlJPUl9ERUxFR0FUT1JfRE9FU19OT1RfRVhJU1RfQVRfVkFMSURBVE9SX0FECiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX2V4aXN0c19kZWxfaW5fbGlzdAogICAgYXNzZXJ0IC8vIERlbGVnYXRvciBjb250cmFjdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgbGlzdCBvZiBhY3RpdmUgZGVsZWdhdG9ycyBvZiB0aGUgdmFsaWRhdG9yIGFkLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMjYzLTEyNjcKICAgIC8vICMgQ2FsbCBicmVhY2hfcGF5IG9mIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QKICAgIC8vIHJlcywgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgRGVsZWdhdG9yQ29udHJhY3QuYnJlYWNoX3BheSwKICAgIC8vICAgICBhcHBfaWQ9ZGVsX2FwcC5pZCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBwdXNoYnl0ZXMgMHg5NTE2MjQ1ZSAvLyBtZXRob2QgImJyZWFjaF9wYXkoKShhZGRyZXNzLGJ5dGVbMTAwXSkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50Y18yIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBBUkM0IHByZWZpeCBpcyB2YWxpZAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMjY5LTEyNzAKICAgIC8vICMgUmVtb3ZlIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QgZnJvbSB0aGUgbGlzdAogICAgLy8gYXNzZXJ0IHNlbGYuX3JlbW92ZV9kZWxfZnJvbV9saXN0KGRlbF9hcHAuaWQpLCBFUlJPUl9GQUlMX1RPX1JFTU9WRV9ERUxFR0FUT1JfQ09OVFJBQ1RfRlJPTV9MSVNUCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX3JlbW92ZV9kZWxfZnJvbV9saXN0CiAgICBhc3NlcnQgLy8gRmFpbGVkIHRvIHJlbW92ZSBkZWxlZ2F0b3IgY29udHJhY3QgZnJvbSB0aGUgbGlzdCBvZiBhY3RpdmUgZGVsZWdhdG9ycyBvZiB0aGUgdmFsaWRhdG9yIGFkLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMjcyCiAgICAvLyByZXR1cm4gcmVzLmNvcHkoKQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnZhbGlkYXRvcl9hZC5jb250cmFjdC5WYWxpZGF0b3JBZC5icmVhY2hfc3VzcGVuZGVkKGRlbF9hcHA6IHVpbnQ2NCkgLT4gYnl0ZXM6CmJyZWFjaF9zdXNwZW5kZWQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEyNzQtMTI3OAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBicmVhY2hfc3VzcGVuZGVkKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX2FwcDogQXBwbGljYXRpb24sCiAgICAvLyApIC0+IEVhcm5pbmdzRGlzdHJpYnV0aW9uQW5kTWVzc2FnZToKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMjk5CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTMwMQogICAgLy8gYXNzZXJ0IHNlbGYuX2V4aXN0c19kZWxfaW5fbGlzdChkZWxfYXBwLmlkKSwgRVJST1JfREVMRUdBVE9SX0RPRVNfTk9UX0VYSVNUX0FUX1ZBTElEQVRPUl9BRAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9leGlzdHNfZGVsX2luX2xpc3QKICAgIGFzc2VydCAvLyBEZWxlZ2F0b3IgY29udHJhY3QgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxpc3Qgb2YgYWN0aXZlIGRlbGVnYXRvcnMgb2YgdGhlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTMwMy0xMzA3CiAgICAvLyAjIENhbGwgYnJlYWNoX3N1c3BlbmRlZCBvZiB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0CiAgICAvLyByZXMsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIERlbGVnYXRvckNvbnRyYWN0LmJyZWFjaF9zdXNwZW5kZWQsCiAgICAvLyAgICAgYXBwX2lkPWRlbF9hcHAuaWQsCiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGJ5dGVzIDB4OTA0NGUyMWYgLy8gbWV0aG9kICJicmVhY2hfc3VzcGVuZGVkKCkoKHVpbnQ2NCx1aW50NjQsdWludDY0KSxhZGRyZXNzLGJ5dGVbMTAwXSkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50Y18yIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBBUkM0IHByZWZpeCBpcyB2YWxpZAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMzA5LTEzMTAKICAgIC8vICMgTWFyayBpbmNyZWFzZSBpbiB2YWxpZGF0b3IncyBlYXJuaW5ncwogICAgLy8gc2VsZi5fbWFya192YWxpZGF0b3JfZWFybmluZ3MocmVzLmVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi5jb3B5KCkpCiAgICBkdXAKICAgIGV4dHJhY3QgMCAyNCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGNhbGxzdWIgX21hcmtfdmFsaWRhdG9yX2Vhcm5pbmdzCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTMxMi0xMzEzCiAgICAvLyAjIFJlbW92ZSB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0IGZyb20gdGhlIGxpc3QKICAgIC8vIGFzc2VydCBzZWxmLl9yZW1vdmVfZGVsX2Zyb21fbGlzdChkZWxfYXBwLmlkKSwgRVJST1JfRkFJTF9UT19SRU1PVkVfREVMRUdBVE9SX0NPTlRSQUNUX0ZST01fTElTVAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9yZW1vdmVfZGVsX2Zyb21fbGlzdAogICAgYXNzZXJ0IC8vIEZhaWxlZCB0byByZW1vdmUgZGVsZWdhdG9yIGNvbnRyYWN0IGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIGRlbGVnYXRvcnMgb2YgdGhlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTMxNQogICAgLy8gcmV0dXJuIHJlcy5jb3B5KCkKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQuY29udHJhY3RfY2xhaW0oZGVsX2FwcDogdWludDY0KSAtPiBieXRlczoKY29udHJhY3RfY2xhaW06CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEzMTctMTMyMQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBjb250cmFjdF9jbGFpbSgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGRlbF9hcHA6IEFwcGxpY2F0aW9uLAogICAgLy8gKSAtPiBFYXJuaW5nc0Rpc3RyaWJ1dGlvbjoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMzM5CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTM0MQogICAgLy8gYXNzZXJ0IHNlbGYuX2V4aXN0c19kZWxfaW5fbGlzdChkZWxfYXBwLmlkKSwgRVJST1JfREVMRUdBVE9SX0RPRVNfTk9UX0VYSVNUX0FUX1ZBTElEQVRPUl9BRAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9leGlzdHNfZGVsX2luX2xpc3QKICAgIGFzc2VydCAvLyBEZWxlZ2F0b3IgY29udHJhY3QgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxpc3Qgb2YgYWN0aXZlIGRlbGVnYXRvcnMgb2YgdGhlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTM0My0xMzQ3CiAgICAvLyAjIENhbGwga2V5c19ub3Rfc3VibWl0dGVkIG9mIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QKICAgIC8vIGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbiwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgRGVsZWdhdG9yQ29udHJhY3QuY29udHJhY3RfY2xhaW0sCiAgICAvLyAgICAgYXBwX2lkPWRlbF9hcHAuaWQsCiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGJ5dGVzIDB4MjZmNTlhNDYgLy8gbWV0aG9kICJjb250cmFjdF9jbGFpbSgpKHVpbnQ2NCx1aW50NjQsdWludDY0KSIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpbnRjXzIgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEzNDktMTM1MAogICAgLy8gIyBNYXJrIGluY3JlYXNlIGluIHZhbGlkYXRvcidzIGVhcm5pbmdzCiAgICAvLyBzZWxmLl9tYXJrX3ZhbGlkYXRvcl9lYXJuaW5ncyhlYXJuaW5nc19kaXN0cmlidXRpb24uY29weSgpKQogICAgZHVwCiAgICBjYWxsc3ViIF9tYXJrX3ZhbGlkYXRvcl9lYXJuaW5ncwogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEzNTIKICAgIC8vIHJldHVybiBlYXJuaW5nc19kaXN0cmlidXRpb24uY29weSgpCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLmNvbnRyYWN0X2V4cGlyZWQoZGVsX2FwcDogdWludDY0KSAtPiBieXRlczoKY29udHJhY3RfZXhwaXJlZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTM1NC0xMzU4CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGNvbnRyYWN0X2V4cGlyZWQoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBkZWxfYXBwOiBBcHBsaWNhdGlvbiwKICAgIC8vICkgLT4gTWVzc2FnZToKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMzc1CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTM3NwogICAgLy8gYXNzZXJ0IHNlbGYuX2V4aXN0c19kZWxfaW5fbGlzdChkZWxfYXBwLmlkKSwgRVJST1JfREVMRUdBVE9SX0RPRVNfTk9UX0VYSVNUX0FUX1ZBTElEQVRPUl9BRAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9leGlzdHNfZGVsX2luX2xpc3QKICAgIGFzc2VydCAvLyBEZWxlZ2F0b3IgY29udHJhY3QgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxpc3Qgb2YgYWN0aXZlIGRlbGVnYXRvcnMgb2YgdGhlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTM3OS0xMzgzCiAgICAvLyAjIENhbGwgY29udHJhY3RfZXhwaXJlZCBvZiB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0CiAgICAvLyByZXMsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIERlbGVnYXRvckNvbnRyYWN0LmNvbnRyYWN0X2V4cGlyZWQsCiAgICAvLyAgICAgYXBwX2lkPWRlbF9hcHAuaWQsCiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGJ5dGVzIDB4Yjg4MzIyYmIgLy8gbWV0aG9kICJjb250cmFjdF9leHBpcmVkKCkoKHVpbnQ2NCx1aW50NjQsdWludDY0KSxhZGRyZXNzLGJ5dGVbMTAwXSkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50Y18yIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBBUkM0IHByZWZpeCBpcyB2YWxpZAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMzg1LTEzODYKICAgIC8vICMgTWFyayBpbmNyZWFzZSBpbiB2YWxpZGF0b3IncyBlYXJuaW5ncwogICAgLy8gc2VsZi5fbWFya192YWxpZGF0b3JfZWFybmluZ3MocmVzLmVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi5jb3B5KCkpCiAgICBkdXAKICAgIGV4dHJhY3QgMCAyNCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGNhbGxzdWIgX21hcmtfdmFsaWRhdG9yX2Vhcm5pbmdzCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTM4OC0xMzg5CiAgICAvLyAjIFJlbW92ZSB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0IGZyb20gdGhlIGxpc3QKICAgIC8vIGFzc2VydCBzZWxmLl9yZW1vdmVfZGVsX2Zyb21fbGlzdChkZWxfYXBwLmlkKSwgRVJST1JfRkFJTF9UT19SRU1PVkVfREVMRUdBVE9SX0NPTlRSQUNUX0ZST01fTElTVAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9yZW1vdmVfZGVsX2Zyb21fbGlzdAogICAgYXNzZXJ0IC8vIEZhaWxlZCB0byByZW1vdmUgZGVsZWdhdG9yIGNvbnRyYWN0IGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIGRlbGVnYXRvcnMgb2YgdGhlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTM5MgogICAgLy8gZGVsX21hbmFnZXI9cmVzLmRlbF9tYW5hZ2VyLAogICAgZHVwCiAgICBleHRyYWN0IDI0IDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMzkzCiAgICAvLyBtc2c9cmVzLm1zZy5jb3B5KCksCiAgICBzd2FwCiAgICBleHRyYWN0IDU2IDEwMCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTM5MS0xMzk0CiAgICAvLyByZXR1cm4gTWVzc2FnZSgKICAgIC8vICAgICBkZWxfbWFuYWdlcj1yZXMuZGVsX21hbmFnZXIsCiAgICAvLyAgICAgbXNnPXJlcy5tc2cuY29weSgpLAogICAgLy8gKQogICAgY29uY2F0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLmNvbnRyYWN0X3dpdGhkcmF3KGRlbF9tYW5hZ2VyOiBieXRlcywgZGVsX2FwcDogdWludDY0KSAtPiB2b2lkOgpjb250cmFjdF93aXRoZHJhdzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTM5Ni0xNDAxCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGNvbnRyYWN0X3dpdGhkcmF3KAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX21hbmFnZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICBkZWxfYXBwOiBBcHBsaWNhdGlvbiwKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDE0CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTQxNgogICAgLy8gYXNzZXJ0IHNlbGYuX2V4aXN0c19kZWxfaW5fbGlzdChkZWxfYXBwLmlkKSwgRVJST1JfREVMRUdBVE9SX0RPRVNfTk9UX0VYSVNUX0FUX1ZBTElEQVRPUl9BRAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9leGlzdHNfZGVsX2luX2xpc3QKICAgIGFzc2VydCAvLyBEZWxlZ2F0b3IgY29udHJhY3QgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxpc3Qgb2YgYWN0aXZlIGRlbGVnYXRvcnMgb2YgdGhlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTQxOC0xNDIzCiAgICAvLyAjIENhbGwgY29udHJhY3Rfd2l0aGRyYXcgb2YgdGhlIGRlbGVnYXRvciBjb250cmFjdAogICAgLy8gZWFybmluZ3NfZGlzdHJpYnV0aW9uLCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBEZWxlZ2F0b3JDb250cmFjdC5jb250cmFjdF93aXRoZHJhdywKICAgIC8vICAgICBkZWxfbWFuYWdlciwKICAgIC8vICAgICBhcHBfaWQ9ZGVsX2FwcC5pZCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBwdXNoYnl0ZXMgMHhmNTNiOTVjZCAvLyBtZXRob2QgImNvbnRyYWN0X3dpdGhkcmF3KGFkZHJlc3MpKHVpbnQ2NCx1aW50NjQsdWludDY0KSIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpbnRjXzIgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE0MjUtMTQyNgogICAgLy8gIyBNYXJrIGluY3JlYXNlIGluIHZhbGlkYXRvcidzIGVhcm5pbmdzCiAgICAvLyBzZWxmLl9tYXJrX3ZhbGlkYXRvcl9lYXJuaW5ncyhlYXJuaW5nc19kaXN0cmlidXRpb24uY29weSgpKQogICAgY2FsbHN1YiBfbWFya192YWxpZGF0b3JfZWFybmluZ3MKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDI4LTE0MjkKICAgIC8vICMgUmVtb3ZlIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QgZnJvbSB0aGUgbGlzdAogICAgLy8gYXNzZXJ0IHNlbGYuX3JlbW92ZV9kZWxfZnJvbV9saXN0KGRlbF9hcHAuaWQpLCBFUlJPUl9GQUlMX1RPX1JFTU9WRV9ERUxFR0FUT1JfQ09OVFJBQ1RfRlJPTV9MSVNUCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX3JlbW92ZV9kZWxfZnJvbV9saXN0CiAgICBhc3NlcnQgLy8gRmFpbGVkIHRvIHJlbW92ZSBkZWxlZ2F0b3IgY29udHJhY3QgZnJvbSB0aGUgbGlzdCBvZiBhY3RpdmUgZGVsZWdhdG9ycyBvZiB0aGUgdmFsaWRhdG9yIGFkLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDMxCiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQuY29udHJhY3RfZGVsZXRlKGRlbF9tYW5hZ2VyOiBieXRlcywgZGVsX2FwcDogdWludDY0KSAtPiBieXRlczoKY29udHJhY3RfZGVsZXRlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDMzLTE0MzgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgY29udHJhY3RfZGVsZXRlKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX21hbmFnZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICBkZWxfYXBwOiBBcHBsaWNhdGlvbiwKICAgIC8vICkgLT4gQ29udHJhY3REZWxldGVSZXR1cm46CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTQ1MAogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE0NTIKICAgIC8vIG1icl9jdXIgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTQ1NC0xNDU5CiAgICAvLyAjIENhbGwgY29udHJhY3RfZGVsZXRlIG9mIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QKICAgIC8vIHJlbWFpbmluZ19iYWxhbmNlLCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBEZWxlZ2F0b3JDb250cmFjdC5jb250cmFjdF9kZWxldGUsCiAgICAvLyAgICAgZGVsX21hbmFnZXIsCiAgICAvLyAgICAgYXBwX2lkPWRlbF9hcHAuaWQsCiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICBwdXNoaW50IDUgLy8gRGVsZXRlQXBwbGljYXRpb24KICAgIGl0eG5fZmllbGQgT25Db21wbGV0aW9uCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGJ5dGVzIDB4ZjJlNjc5MzQgLy8gbWV0aG9kICJjb250cmFjdF9kZWxldGUoYWRkcmVzcykodWludDY0LHVpbnQ2NCkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0yCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50Y18yIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBBUkM0IHByZWZpeCBpcyB2YWxpZAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDYxCiAgICAvLyBtYnJfbmV3ID0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE0NjIKICAgIC8vIGFtdCA9IG1icl9jdXIgLSBtYnJfbmV3CiAgICB1bmNvdmVyIDIKICAgIHN3YXAKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTQ2NC0xNDY4CiAgICAvLyAjIFNlbmQgdGhlIGZyZWVkIE1CUiB0byBkZWxlZ2F0b3IgbWFuYWdlcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPWRlbF9tYW5hZ2VyLm5hdGl2ZSwKICAgIC8vICAgICBhbW91bnQ9YW10LAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDY0LTE0NjUKICAgIC8vICMgU2VuZCB0aGUgZnJlZWQgTUJSIHRvIGRlbGVnYXRvciBtYW5hZ2VyCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICBpbnRjXzEgLy8gcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTQ2NC0xNDY4CiAgICAvLyAjIFNlbmQgdGhlIGZyZWVkIE1CUiB0byBkZWxlZ2F0b3IgbWFuYWdlcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPWRlbF9tYW5hZ2VyLm5hdGl2ZSwKICAgIC8vICAgICBhbW91bnQ9YW10LAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTQ3MAogICAgLy8gcmV0dXJuIHJlbWFpbmluZ19iYWxhbmNlCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLmNvbnRyYWN0X3JlcG9ydF9leHBpcnlfc29vbihiZWZvcmVfZXhwaXJ5OiB1aW50NjQsIHJlcG9ydF9wZXJpb2Q6IHVpbnQ2NCwgZGVsX2FwcDogdWludDY0KSAtPiBieXRlczoKY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDcyLTE0NzgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgYmVmb3JlX2V4cGlyeTogVUludDY0LAogICAgLy8gICAgIHJlcG9ydF9wZXJpb2Q6IFVJbnQ2NCwKICAgIC8vICAgICBkZWxfYXBwOiBBcHBsaWNhdGlvbiwKICAgIC8vICkgLT4gTWVzc2FnZToKICAgIHByb3RvIDMgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDk5CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTUwMS0xNTA3CiAgICAvLyAjIENhbGwgY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uIG9mIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QKICAgIC8vIHJlcywgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgRGVsZWdhdG9yQ29udHJhY3QuY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uLAogICAgLy8gICAgIGJlZm9yZV9leHBpcnksCiAgICAvLyAgICAgcmVwb3J0X3BlcmlvZCwKICAgIC8vICAgICBhcHBfaWQ9ZGVsX2FwcC5pZCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTUwNAogICAgLy8gYmVmb3JlX2V4cGlyeSwKICAgIGZyYW1lX2RpZyAtMwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTA1CiAgICAvLyByZXBvcnRfcGVyaW9kLAogICAgZnJhbWVfZGlnIC0yCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTAxLTE1MDcKICAgIC8vICMgQ2FsbCBjb250cmFjdF9yZXBvcnRfZXhwaXJ5X3Nvb24gb2YgdGhlIGRlbGVnYXRvciBjb250cmFjdAogICAgLy8gcmVzLCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBEZWxlZ2F0b3JDb250cmFjdC5jb250cmFjdF9yZXBvcnRfZXhwaXJ5X3Nvb24sCiAgICAvLyAgICAgYmVmb3JlX2V4cGlyeSwKICAgIC8vICAgICByZXBvcnRfcGVyaW9kLAogICAgLy8gICAgIGFwcF9pZD1kZWxfYXBwLmlkLAogICAgLy8gKQogICAgcHVzaGJ5dGVzIDB4ZWFmYTFlMTUgLy8gbWV0aG9kICJjb250cmFjdF9yZXBvcnRfZXhwaXJ5X3Nvb24odWludDY0LHVpbnQ2NCkoYWRkcmVzcyxieXRlWzEwMF0pIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50Y18yIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBBUkM0IHByZWZpeCBpcyB2YWxpZAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTA5CiAgICAvLyByZXR1cm4gcmVzCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLmdldF92YWxpZGF0b3JfYXNhKGFzc2V0X2lkOiB1aW50NjQpIC0+IGJ5dGVzOgpnZXRfdmFsaWRhdG9yX2FzYToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTUyMC0xNTI3CiAgICAvLyAjIC0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tLS0tLS0tLS0tLS0tLSAtLS0tLSAtLS0tLSAtLS0tLQogICAgLy8gIyAtLS0tLSAtLS0tLSAtLS0tLSBSZWFkLW9ubHkgZnVuY3Rpb25zIC0tLS0tIC0tLS0tIC0tLS0KICAgIC8vICMgLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0tLS0tLS0tLS0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIC8vIGRlZiBnZXRfdmFsaWRhdG9yX2FzYSgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGFzc2V0X2lkIDogVUludDY0LAogICAgLy8gKSAtPiBWYWxpZGF0b3JBU0E6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTUzNwogICAgLy8gcmV0dXJuIHNlbGYuYXNhc1tBc3NldChhc3NldF9pZCldCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIGJ5dGVjIDEzIC8vIDB4NjE3MzYxNWYKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYXNhcyBlbnRyeSBleGlzdHMKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQuX3JlbW92ZV9kZWxfZnJvbV9saXN0KGRlbF9hcHBfaWQ6IHVpbnQ2NCkgLT4gdWludDY0OgpfcmVtb3ZlX2RlbF9mcm9tX2xpc3Q6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1NTUtMTU1NgogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBfcmVtb3ZlX2RlbF9mcm9tX2xpc3Qoc2VsZiwgZGVsX2FwcF9pZDogVUludDY0KSAtPiBib29sOgogICAgcHJvdG8gMSAxCiAgICBwdXNoYnl0ZXMgIiIKICAgIGR1cG4gMgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTU4CiAgICAvLyBkZWxfcmVtb3ZlZCA9IEZhbHNlCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTU5CiAgICAvLyBmb3IgZGVsX2lkeCBpbiB1cmFuZ2UoTUFYSU1VTV9OVU1CRVJfT0ZfREVMRUdBVE9SX0NPTlRSQUNUU19QRVJfVkFMSURBVE9SX0FEKToKICAgIGR1cAoKX3JlbW92ZV9kZWxfZnJvbV9saXN0X2Zvcl9oZWFkZXJAMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU1OQogICAgLy8gZm9yIGRlbF9pZHggaW4gdXJhbmdlKE1BWElNVU1fTlVNQkVSX09GX0RFTEVHQVRPUl9DT05UUkFDVFNfUEVSX1ZBTElEQVRPUl9BRCk6CiAgICBmcmFtZV9kaWcgNAogICAgcHVzaGludCAxNCAvLyAxNAogICAgPAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDAKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9idXJ5IDEKICAgIGJ6IF9yZW1vdmVfZGVsX2Zyb21fbGlzdF9hZnRlcl9mb3JANgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTYwCiAgICAvLyBpZiBzZWxmLmRlbF9hcHBfbGlzdFtkZWxfaWR4XSA9PSBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKToKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA1IC8vICJkZWxfYXBwX2xpc3QiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX2FwcF9saXN0IGV4aXN0cwogICAgZnJhbWVfZGlnIDQKICAgIHB1c2hpbnQgOCAvLyA4CiAgICAqCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMgogICAgcHVzaGludCA4IC8vIDgKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBiPT0KICAgIGJ6IF9yZW1vdmVfZGVsX2Zyb21fbGlzdF9hZnRlcl9pZl9lbHNlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU2MQogICAgLy8gc2VsZi5kZWxfYXBwX2xpc3RbZGVsX2lkeF0gPSBhcmM0LlVJbnQ2NCgwKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDUgLy8gImRlbF9hcHBfbGlzdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxfYXBwX2xpc3QgZXhpc3RzCiAgICBmcmFtZV9kaWcgMAogICAgYXNzZXJ0IC8vIEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBmcmFtZV9kaWcgMgogICAgYnl0ZWMgMjQgLy8gMHgwMDAwMDAwMDAwMDAwMDAwCiAgICByZXBsYWNlMwogICAgYnl0ZWMgNSAvLyAiZGVsX2FwcF9saXN0IgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU2MgogICAgLy8gZGVsX3JlbW92ZWQgPSBUcnVlCiAgICBpbnRjXzEgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTYzCiAgICAvLyBzZWxmLmNudF9kZWwgLT0gMQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDQgLy8gImNudF9kZWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuY250X2RlbCBleGlzdHMKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBieXRlYyA0IC8vICJjbnRfZGVsIgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIGZyYW1lX2J1cnkgMQoKX3JlbW92ZV9kZWxfZnJvbV9saXN0X2FmdGVyX2ZvckA2OgogICAgZnJhbWVfZGlnIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU2NgogICAgLy8gcmV0dXJuIGRlbF9yZW1vdmVkCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKX3JlbW92ZV9kZWxfZnJvbV9saXN0X2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU1OQogICAgLy8gZm9yIGRlbF9pZHggaW4gdXJhbmdlKE1BWElNVU1fTlVNQkVSX09GX0RFTEVHQVRPUl9DT05UUkFDVFNfUEVSX1ZBTElEQVRPUl9BRCk6CiAgICBmcmFtZV9kaWcgNAogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGZyYW1lX2J1cnkgNAogICAgYiBfcmVtb3ZlX2RlbF9mcm9tX2xpc3RfZm9yX2hlYWRlckAxCgoKLy8gc21hcnRfY29udHJhY3RzLnZhbGlkYXRvcl9hZC5jb250cmFjdC5WYWxpZGF0b3JBZC5fZXhpc3RzX2RlbF9pbl9saXN0KGRlbF9hcHBfaWQ6IHVpbnQ2NCkgLT4gdWludDY0OgpfZXhpc3RzX2RlbF9pbl9saXN0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTY4LTE1NjkKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgX2V4aXN0c19kZWxfaW5fbGlzdChzZWxmLCBkZWxfYXBwX2lkOiBVSW50NjQpIC0+IGJvb2w6CiAgICBwcm90byAxIDEKICAgIHB1c2hieXRlcyAiIgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTcxCiAgICAvLyBkZWxfZXhpc3RzID0gRmFsc2UKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1NzIKICAgIC8vIGZvciBkZWxfaWR4IGluIHVyYW5nZShNQVhJTVVNX05VTUJFUl9PRl9ERUxFR0FUT1JfQ09OVFJBQ1RTX1BFUl9WQUxJREFUT1JfQUQpOgogICAgZHVwCgpfZXhpc3RzX2RlbF9pbl9saXN0X2Zvcl9oZWFkZXJAMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU3MgogICAgLy8gZm9yIGRlbF9pZHggaW4gdXJhbmdlKE1BWElNVU1fTlVNQkVSX09GX0RFTEVHQVRPUl9DT05UUkFDVFNfUEVSX1ZBTElEQVRPUl9BRCk6CiAgICBmcmFtZV9kaWcgMgogICAgcHVzaGludCAxNCAvLyAxNAogICAgPAogICAgZnJhbWVfZGlnIDEKICAgIGZyYW1lX2J1cnkgMAogICAgYnogX2V4aXN0c19kZWxfaW5fbGlzdF9hZnRlcl9mb3JANgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTczCiAgICAvLyBpZiBzZWxmLmRlbF9hcHBfbGlzdFtkZWxfaWR4XSA9PSBhcmM0LlVJbnQ2NChkZWxfYXBwX2lkKToKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA1IC8vICJkZWxfYXBwX2xpc3QiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX2FwcF9saXN0IGV4aXN0cwogICAgZnJhbWVfZGlnIDIKICAgIHB1c2hpbnQgOCAvLyA4CiAgICAqCiAgICBwdXNoaW50IDggLy8gOAogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIGI9PQogICAgYnogX2V4aXN0c19kZWxfaW5fbGlzdF9hZnRlcl9pZl9lbHNlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU3NAogICAgLy8gZGVsX2V4aXN0cyA9IFRydWUKICAgIGludGNfMSAvLyAxCiAgICBmcmFtZV9idXJ5IDAKCl9leGlzdHNfZGVsX2luX2xpc3RfYWZ0ZXJfZm9yQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1NzcKICAgIC8vIHJldHVybiBkZWxfZXhpc3RzCiAgICByZXRzdWIKCl9leGlzdHNfZGVsX2luX2xpc3RfYWZ0ZXJfaWZfZWxzZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTcyCiAgICAvLyBmb3IgZGVsX2lkeCBpbiB1cmFuZ2UoTUFYSU1VTV9OVU1CRVJfT0ZfREVMRUdBVE9SX0NPTlRSQUNUU19QRVJfVkFMSURBVE9SX0FEKToKICAgIGZyYW1lX2RpZyAyCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSAyCiAgICBiIF9leGlzdHNfZGVsX2luX2xpc3RfZm9yX2hlYWRlckAxCgoKLy8gc21hcnRfY29udHJhY3RzLnZhbGlkYXRvcl9hZC5jb250cmFjdC5WYWxpZGF0b3JBZC5fbWFya192YWxpZGF0b3JfZWFybmluZ3MoZWFybmluZ3NfZGlzdHJpYnV0aW9uOiBieXRlcykgLT4gYnl0ZXM6Cl9tYXJrX3ZhbGlkYXRvcl9lYXJuaW5nczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU3OS0xNTgwCiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIF9tYXJrX3ZhbGlkYXRvcl9lYXJuaW5ncyhzZWxmLCBlYXJuaW5nc19kaXN0cmlidXRpb246IEVhcm5pbmdzRGlzdHJpYnV0aW9uKSAtPiBOb25lOgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1ODIKICAgIC8vIGFzc2V0X2lkID0gZWFybmluZ3NfZGlzdHJpYnV0aW9uLmFzc2V0X2lkLm5hdGl2ZQogICAgZnJhbWVfZGlnIC0xCiAgICBleHRyYWN0IDE2IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU4MwogICAgLy8gaWYgYXNzZXRfaWQgIT0gVUludDY0KEFMR09fQVNBX0lEKToKICAgIGJ6IF9tYXJrX3ZhbGlkYXRvcl9lYXJuaW5nc19lbHNlX2JvZHlAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTg2CiAgICAvLyBzZWxmLmFzYXNbYXNzZXRdLnRvdGFsX2Vhcm5pbmcubmF0aXZlICsgZWFybmluZ3NfZGlzdHJpYnV0aW9uLnVzZXIubmF0aXZlCiAgICBmcmFtZV9kaWcgMAogICAgaXRvYgogICAgYnl0ZWMgMTMgLy8gMHg2MTczNjE1ZgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmFzYXMgZW50cnkgZXhpc3RzCiAgICBleHRyYWN0IDAgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGZyYW1lX2RpZyAtMQogICAgZXh0cmFjdCAwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1ODUtMTU4NwogICAgLy8gc2VsZi5hc2FzW2Fzc2V0XS50b3RhbF9lYXJuaW5nID0gYXJjNC5VSW50NjQoCiAgICAvLyAgICAgc2VsZi5hc2FzW2Fzc2V0XS50b3RhbF9lYXJuaW5nLm5hdGl2ZSArIGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi51c2VyLm5hdGl2ZQogICAgLy8gKQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTg1CiAgICAvLyBzZWxmLmFzYXNbYXNzZXRdLnRvdGFsX2Vhcm5pbmcgPSBhcmM0LlVJbnQ2NCgKICAgIGRpZyAxCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5hc2FzIGVudHJ5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTg1LTE1ODcKICAgIC8vIHNlbGYuYXNhc1thc3NldF0udG90YWxfZWFybmluZyA9IGFyYzQuVUludDY0KAogICAgLy8gICAgIHNlbGYuYXNhc1thc3NldF0udG90YWxfZWFybmluZy5uYXRpdmUgKyBlYXJuaW5nc19kaXN0cmlidXRpb24udXNlci5uYXRpdmUKICAgIC8vICkKICAgIHN3YXAKICAgIHJlcGxhY2UyIDAKICAgIGRpZyAxCiAgICBzd2FwCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1ODkKICAgIC8vIHNlbGYuYXNhc1thc3NldF0udG90YWxfZmVlc19nZW5lcmF0ZWQubmF0aXZlICsgZWFybmluZ3NfZGlzdHJpYnV0aW9uLnBsYXRmb3JtLm5hdGl2ZQogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5hc2FzIGVudHJ5IGV4aXN0cwogICAgZXh0cmFjdCA4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgOCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTg4LTE1OTAKICAgIC8vIHNlbGYuYXNhc1thc3NldF0udG90YWxfZmVlc19nZW5lcmF0ZWQgPSBhcmM0LlVJbnQ2NCgKICAgIC8vICAgICBzZWxmLmFzYXNbYXNzZXRdLnRvdGFsX2ZlZXNfZ2VuZXJhdGVkLm5hdGl2ZSArIGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi5wbGF0Zm9ybS5uYXRpdmUKICAgIC8vICkKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU4OAogICAgLy8gc2VsZi5hc2FzW2Fzc2V0XS50b3RhbF9mZWVzX2dlbmVyYXRlZCA9IGFyYzQuVUludDY0KAogICAgZGlnIDEKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmFzYXMgZW50cnkgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1ODgtMTU5MAogICAgLy8gc2VsZi5hc2FzW2Fzc2V0XS50b3RhbF9mZWVzX2dlbmVyYXRlZCA9IGFyYzQuVUludDY0KAogICAgLy8gICAgIHNlbGYuYXNhc1thc3NldF0udG90YWxfZmVlc19nZW5lcmF0ZWQubmF0aXZlICsgZWFybmluZ3NfZGlzdHJpYnV0aW9uLnBsYXRmb3JtLm5hdGl2ZQogICAgLy8gKQogICAgc3dhcAogICAgcmVwbGFjZTIgOAogICAgYm94X3B1dAoKX21hcmtfdmFsaWRhdG9yX2Vhcm5pbmdzX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU5NQogICAgLy8gcmV0dXJuCiAgICBmcmFtZV9kaWcgLTEKICAgIHN3YXAKICAgIHJldHN1YgoKX21hcmtfdmFsaWRhdG9yX2Vhcm5pbmdzX2Vsc2VfYm9keUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTkyCiAgICAvLyBzZWxmLnRvdGFsX2FsZ29fZWFybmVkICs9IGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi51c2VyLm5hdGl2ZQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDE4IC8vICJ0b3RhbF9hbGdvX2Vhcm5lZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50b3RhbF9hbGdvX2Vhcm5lZCBleGlzdHMKICAgIGZyYW1lX2RpZyAtMQogICAgZXh0cmFjdCAwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICArCiAgICBieXRlYyAxOCAvLyAidG90YWxfYWxnb19lYXJuZWQiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTkzCiAgICAvLyBzZWxmLnRvdGFsX2FsZ29fZmVlc19nZW5lcmF0ZWQgKz0gZWFybmluZ3NfZGlzdHJpYnV0aW9uLnBsYXRmb3JtLm5hdGl2ZQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDE5IC8vICJ0b3RhbF9hbGdvX2ZlZXNfZ2VuZXJhdGVkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRvdGFsX2FsZ29fZmVlc19nZW5lcmF0ZWQgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgOCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgKwogICAgYnl0ZWMgMTkgLy8gInRvdGFsX2FsZ29fZmVlc19nZW5lcmF0ZWQiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYiBfbWFya192YWxpZGF0b3JfZWFybmluZ3NfYWZ0ZXJfaWZfZWxzZUAzCg==",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K"
  },
  "state": {
    "global": {
      "num_byte_slices": 11,
      "num_uints": 6
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0
    }
  },
  "schema": {
    "global": {
      "declared": {
        "cnt_asa": {
          "type": "uint64",
          "key": "cnt_asa"
        },
        "cnt_del": {
          "type": "uint64",
          "key": "cnt_del"
        },
        "cnt_del_max": {
          "type": "uint64",
          "key": "cnt_del_max"
        },
        "del_app_list": {
          "type": "bytes",
          "key": "del_app_list"
        },
        "noticeboard_app_id": {
          "type": "uint64",
          "key": "noticeboard_app_id"
        },
        "state": {
          "type": "bytes",
          "key": "state"
        },
        "tc_sha256": {
          "type": "bytes",
          "key": "tc_sha256"
        },
        "terms_price": {
          "type": "bytes",
          "key": "P"
        },
        "terms_reqs": {
          "type": "bytes",
          "key": "G"
        },
        "terms_stake": {
          "type": "bytes",
          "key": "S"
        },
        "terms_time": {
          "type": "bytes",
          "key": "T"
        },
        "terms_warn": {
          "type": "bytes",
          "key": "W"
        },
        "total_algo_earned": {
          "type": "uint64",
          "key": "total_algo_earned"
        },
        "total_algo_fees_generated": {
          "type": "uint64",
          "key": "total_algo_fees_generated"
        },
        "val_info": {
          "type": "bytes",
          "key": "V",
          "descr": "Self-disclosed information about validator."
        },
        "val_manager": {
          "type": "bytes",
          "key": "val_manager"
        },
        "val_owner": {
          "type": "bytes",
          "key": "val_owner"
        }
      },
      "reserved": {}
    },
    "local": {
      "declared": {},
      "reserved": {}
    }
  },
  "contract": {
    "name": "ValidatorAd",
    "desc": "\n    Ad of a validator owner to offer node running services to users.\n    Users, i.e. delegators, can open requests for the service and conclude an individual delegator contract with the\n    validator.\n    The contract terms are defined by this ad contents at time of the creation of the delegator contract.\n    The validator owner can change the ad to offer different terms for future delegator contracts.\n    The validator ad smart contract also acts as an escrow account for the payment received by the validator from\n    delegators for its service.\n\n    Global state\n    ------------\n    noticeboard_app_id : UInt64\n        App ID of noticeboard platform to which this contract belongs to.\n\n    terms_time: ValidatorTermsTiming\n        Validator's terms about timing.\n    terms_price: ValidatorTermsPricing\n        Validator's terms about pricing.\n    terms_stake: ValidatorTermsStakeLimits\n        Validator's terms about stake limits.\n    terms_reqs: ValidatorTermsGating\n        Validator's terms about gating requirements.\n    terms_warn: ValidatorTermsWarnings\n        Validator's terms about warnings.\n\n    delegation_terms_general : DelegationTermsGeneral\n        General delegation terms that validator defines and agrees to respect if a delegator concludes a delegator\n        contract based on them.\n    delegation_terms_balance : DelegationTermsBalance\n        Requirements for delegator beneficiary balance that validator defines and agrees to respect if a delegator\n        concludes a delegator contract based on them.\n\n    val_owner : Account\n        Validator owner account.\n    val_manager : Account\n        Validator manager account.\n\n    val_info : ValidatorSelfDisclosure\n        Self-disclosed information about the validator.\n\n    state : Bytes\n        State of the contract. Can be one of the following:\n            CREATED - validator ad has been created.\n            TEMPLATE_LOAD - validator ad is getting loaded the delegator contract template.\n            TEMPLATE_LOADED - validator ad ended loading of the delegator contract template.\n            SET - initial terms of validator ad have been set.\n            READY - validator ad manager is ready to accept new delegators.\n            NOT_READY - validator ad manager is not ready to accept new delegators.\n            NOT_LIVE - validator ad owner does not want to accept new delegators.\n\n    cnt_del : UInt64\n        Counter of current delegators.\n    cnt_del_max : UInt64\n        Maximum number of delegators the validator is willing to manage simultaneously.\n    del_app_list : DelAppList\n        List of app ID of the currently active delegator contracts.\n\n    tc_sha256 : Sha256\n        Hash (i.e. SHA 256) of the Terms and Conditions agreed by the validator.\n\n    total_algo_earned : UInt64\n        Total amount of ALGO the validator ad has earned.\n    total_algo_fees_generated : UInt64\n        Total amount of ALGO the validator has generated as fees for the platform.\n\n    cnt_asa : UInt64\n        Counter of number of different ASAs supported by the contract.\n\n    Box storage\n    -----------\n    asas : asa_[ASA_ID] = ValidatorASA\n        Box map for storing ASA IDs that are or were supported by the validator ad at any point of time before deletion.\n        Each entry is a ValidatorASA, with fields for total_earnings and total_fees_generated for that ASA.\n        Keys correspond to \"asa_\" followed by byte representation of ASA ID.\n\n    template : BOX_DELEGATOR_CONTRACT_TEMPLATE_KEY = Bytes\n        Box for storing the delegator contract template.\n\n    Methods\n    -------\n    ad_create(\n        val_owner: arc4.Address,\n    ) -> arc4.UInt64:\n        Creates a new validator ad and returns its app ID.\n\n    ad_config(\n        val_owner: arc4.Address,\n        val_manager: arc4.Address,\n        live : arc4.Bool,\n        cnt_del_max : UInt64,\n    ) -> None:\n        Set the operational configuration of the validator ad.\n\n    ad_delete(\n        val_owner: arc4.Address,\n    ) -> None:\n        Validator owner deletes a validator ad.\n\n    ad_ready(\n        val_manager: arc4.Address,\n        ready: arc4.Bool,\n    ) -> None:\n        Ad manager sets its readiness for operation.\n\n    ad_self_disclose(\n        val_owner: arc4.Address,\n        val_info: ValidatorSelfDisclosure,\n    ) -> None:\n        Ad owner sets its self-disclosure information.\n\n    ad_terms(\n        val_owner: arc4.Address,\n        tc_sha256: Sha256,\n        terms_time: ValidatorTermsTiming,\n        terms_price: ValidatorTermsPricing,\n        terms_stake: ValidatorTermsStakeLimits,\n        terms_reqs: ValidatorTermsGating,\n        terms_warn: ValidatorTermsWarnings,\n        txn: gtxn.PaymentTransaction,\n    ) -> None:\n        Sets all the terms of the validator.\n\n    ad_income(\n        val_owner: arc4.Address,\n        asset_id: UInt64,\n    ) -> arc4.UInt64:\n        Validator owner withdraws all available balance from the validator ad for the given asset.\n\n    ad_asa_close(\n        val_owner: arc4.Address,\n        asset_id: UInt64,\n    ) -> None:\n        Removes the asset's storage on the validator ad.\n\n    template_load_init(\n        val_owner: arc4.Address,\n        template_size: UInt64,\n        mbr_txn: gtxn.PaymentTransaction,\n    ) -> None:\n        Starts the process of uploading delegator contract template.\n\n    template_load_data(\n        val_owner: arc4.Address,\n        offset: UInt64,\n        data: Bytes,\n    ) -> None:\n        Uploads a data chunk to the delegator contract template.\n\n    template_load_end(\n        val_owner: arc4.Address,\n    ) -> None:\n        Ends uploading of the delegator contract template.\n\n    contract_create(\n        del_manager: arc4.Address,\n        del_beneficiary: arc4.Address,\n        rounds_duration: UInt64,\n        stake_max: UInt64,\n        partner_address: arc4.Address,\n        partner_commissions: PartnerCommissions,\n        mbr_txn: gtxn.PaymentTransaction,\n        txn: gtxn.Transaction,\n    ) -> arc4.UInt64:\n        Creates a new delegator contract with the current delegation terms for the input\n        delegator contract manager and delegator contract beneficiary with the specified duration.\n\n    keys_confirm(\n        del_manager: arc4.Address,\n        del_app: Application,\n    ) -> None:\n        Delegator manager confirms that the keys have been confirmed by the delegator beneficiary.\n\n    keys_not_confirmed(\n        del_app: Application,\n    ) -> Message:\n        Reports that keys of a delegator contract have not been confirmed in time.\n\n    keys_not_submitted(\n        del_app: Application,\n    ) -> Message:\n        Reports that keys of a delegator contract have not been submitted in time.\n\n    keys_submit(\n        val_manager: arc4.Address,\n        del_app: Application,\n        key_reg_txn_info : KeyRegTxnInfo,\n    ) -> Message:\n        Validator manager submits the keys generated for the delegator beneficiary according to the contract terms.\n\n    breach_limits(\n        del_app: Application,\n    ) -> BreachLimitsReturn:\n        Reports that a limit breach event occurred on the delegator beneficiary.\n\n    breach_pay(\n        del_app: Application,\n    ) -> Message:\n        Reports that a payment for the fee cannot be made from the delegator beneficiary.\n\n    breach_suspended(\n        del_app: Application,\n    ) -> EarningsDistributionAndMessage:\n        Reports that the delegator beneficiary was suspended by consensus.\n\n    contract_claim(\n        del_app: Application,\n    ) -> EarningsDistribution:\n        Claims and distributes the operational fee of validator up to this round to the validator and noticeboard.\n\n    contract_expired(\n        del_app: Application,\n    ) -> Message:\n        Reports that a delegator contract has expired.\n\n    contract_withdraw(\n        del_manager: arc4.Address,\n        del_app: Application,\n    ) -> None:\n        Reports that a delegator has gracefully withdrawn from the delegator contract prematurely.\n\n    contract_delete(\n        del_manager: arc4.Address,\n        del_app: Application,\n    ) -> ContractDeleteReturn:\n        Delegator deletes an ended contract, withdraws any remaining balance, and returns the MBR from ValidatorAd.\n\n    contract_report_expiry_soon(\n        before_expiry: UInt64,\n        report_period: UInt64,\n    ) -> Message:\n        Reports that the contract will expire soon.\n\n    gas(\n    ) -> None:\n        To fit more resources in app reference arrays.\n\n    Private methods\n    ---------------\n    _add_del_to_list(self, del_app_id: UInt64) -> bool:\n        Assign created delegator contract to first free space in the list of delegator contracts.\n\n    _remove_del_from_list(self, del_app_id: UInt64) -> bool:\n        Remove the delegator contract from list of delegator contracts.\n\n    _exists_del_in_list(self, del_app_id: UInt64) -> bool:\n        Checks if a delegator contract exists in validator ad's list of delegator contracts.\n\n    _mark_validator_earnings(self, earnings_distribution: EarningsDistribution) -> None:\n        Mark increase in validator's earnings.\n\n    ",
    "methods": [
      {
        "name": "ad_create",
        "args": [
          {
            "type": "address",
            "name": "val_owner",
            "desc": "Owner address for the validator ad."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "uint64",
          "desc": "App ID of the created validator ad application."
        },
        "desc": "Creates a new ValidatorAd.\nDefines validator ad owner account. Defines Noticeboard app ID to which this contract belongs to."
      },
      {
        "name": "ad_config",
        "args": [
          {
            "type": "address",
            "name": "val_owner",
            "desc": "Owner address of the validator ad."
          },
          {
            "type": "address",
            "name": "val_manager",
            "desc": "Manager address for the validator ad."
          },
          {
            "type": "bool",
            "name": "live",
            "desc": "Set to True if validator ad should be accepting new delegators, otherwise set to False."
          },
          {
            "type": "uint64",
            "name": "cnt_del_max",
            "desc": "Maximum number of delegators the validator is willing to manage simultaneously."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Sets all operation configuration parameters for the validator ad, i.e.\nthe validator manager account, the status whether the ad is live to accept new delegators (`live=True`) or not (`live=False`), and the maximum number of delegators the validators can accept."
      },
      {
        "name": "ad_delete",
        "args": [
          {
            "type": "address",
            "name": "val_owner",
            "desc": "Owner address of the validator ad."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Validator owner deletes a validator ad.\nPossible only if there are no active delegators and all balances have been claimed."
      },
      {
        "name": "ad_ready",
        "args": [
          {
            "type": "address",
            "name": "val_manager",
            "desc": "Manager address for the validator ad."
          },
          {
            "type": "bool",
            "name": "ready",
            "desc": "Set to True if validator manager is ready for accepting new delegators, otherwise set to False."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Ad manager sets its readiness for operation."
      },
      {
        "name": "ad_self_disclose",
        "args": [
          {
            "type": "address",
            "name": "val_owner",
            "desc": "Owner address of the validator ad."
          },
          {
            "type": "(byte[30],byte[60],byte[2],uint64,byte[20])",
            "name": "val_info",
            "desc": "Self-disclosed information about the validator."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Ad owner sets its self-disclosure information."
      },
      {
        "name": "ad_terms",
        "args": [
          {
            "type": "address",
            "name": "val_owner",
            "desc": "Owner address of the validator ad."
          },
          {
            "type": "byte[32]",
            "name": "tc_sha256",
            "desc": "Hash (i.e. SHA 256) of the Terms and Conditions agreed by the validator."
          },
          {
            "type": "(uint64,uint64,uint64,uint64,uint64)",
            "name": "terms_time",
            "desc": "Validator's terms about timing."
          },
          {
            "type": "(uint64,uint64,uint64,uint64,uint64)",
            "name": "terms_price",
            "desc": "Validator's terms about pricing."
          },
          {
            "type": "(uint64,uint64)",
            "name": "terms_stake",
            "desc": "Validator's terms about stake limits."
          },
          {
            "type": "((uint64,uint64)[2])",
            "name": "terms_reqs",
            "desc": "Validator's terms about gating requirements."
          },
          {
            "type": "(uint64,uint64)",
            "name": "terms_warn",
            "desc": "Validator's terms about warnings."
          },
          {
            "type": "pay",
            "name": "txn",
            "desc": "Transaction for the payment of MBR increase."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Sets all the terms of the validator.\nWith this action, the validator agrees with the (new) terms."
      },
      {
        "name": "ad_income",
        "args": [
          {
            "type": "address",
            "name": "val_owner",
            "desc": "Owner address of the validator ad."
          },
          {
            "type": "uint64",
            "name": "asset_id",
            "desc": "ID of the asset (i.e. ASA ID or 0 for ALGO) for which the owner would like to withdraw all earnings from the validator ad."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "uint64",
          "desc": "Withdrawn income from the validator ad for the input asset."
        },
        "desc": "Validator owner withdraws all available balance from the validator ad for the given asset."
      },
      {
        "name": "ad_asa_close",
        "args": [
          {
            "type": "address",
            "name": "val_owner",
            "desc": "Owner address of the validator ad."
          },
          {
            "type": "uint64",
            "name": "asset_id",
            "desc": "ID of the asset (i.e. ASA ID or 0 for ALGO) for which the owner would like remove its storage."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Removes the asset's storage on the validator ad.\nTo be used before deleting the contract."
      },
      {
        "name": "template_load_init",
        "args": [
          {
            "type": "address",
            "name": "val_owner",
            "desc": "Owner address of the validator ad."
          },
          {
            "type": "uint64",
            "name": "template_size",
            "desc": "Size of the delegator contract template in bytes."
          },
          {
            "type": "pay",
            "name": "mbr_txn",
            "desc": "Payment transaction for the payment of the increase of validator ad MBR due to creation of box for storing the delegator contract template."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Starts the process of uploading delegator contract template."
      },
      {
        "name": "template_load_data",
        "args": [
          {
            "type": "address",
            "name": "val_owner",
            "desc": "Owner address of the validator ad."
          },
          {
            "type": "uint64",
            "name": "offset",
            "desc": "Offset in the box at which to replace the data."
          },
          {
            "type": "byte[]",
            "name": "data",
            "desc": "Data to replace in the box at the defined position."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Uploads a data chunk to the delegator contract template."
      },
      {
        "name": "template_load_end",
        "args": [
          {
            "type": "address",
            "name": "val_owner",
            "desc": "Owner address of the validator ad."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Ends uploading of the delegator contract template."
      },
      {
        "name": "contract_create",
        "args": [
          {
            "type": "address",
            "name": "del_manager",
            "desc": "Manager address for the delegation contract."
          },
          {
            "type": "address",
            "name": "del_beneficiary",
            "desc": "Beneficiary address for the delegation contract."
          },
          {
            "type": "uint64",
            "name": "rounds_duration",
            "desc": "Contract duration in number of rounds."
          },
          {
            "type": "uint64",
            "name": "stake_max",
            "desc": "The maximum amount of ALGO that the delegator beneficiary address intends to have at any point in time during the contract duration."
          },
          {
            "type": "address",
            "name": "partner_address",
            "desc": "Address of the partner that collects the partner convenience fees. If there is no partner, set it to Global.zero_address."
          },
          {
            "type": "(uint64,uint64)",
            "name": "partner_commissions",
            "desc": "Commissions charged on top of validator setup and operational fees, for partner's convenience offer. The values are represented in ppm."
          },
          {
            "type": "pay",
            "name": "mbr_txn",
            "desc": "Payment transaction for the payment of the increase of validator ad MBR due to creation of a new contract."
          },
          {
            "type": "txn",
            "name": "txn",
            "desc": "Transaction for the payment of the setup and operational fee."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "uint64",
          "desc": "App ID of the created delegator contract application."
        },
        "desc": "Creates a new delegator contract with the current delegation terms for the input\ndelegator contract manager and delegator contract beneficiary with the specified duration."
      },
      {
        "name": "keys_confirm",
        "args": [
          {
            "type": "address",
            "name": "del_manager",
            "desc": "Purported delegator manager account."
          },
          {
            "type": "application",
            "name": "del_app"
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Delegator manager confirms that the delegator beneficiary has confirmed the submitted keys\nand pays for the operational fee."
      },
      {
        "name": "keys_not_confirmed",
        "args": [
          {
            "type": "application",
            "name": "del_app",
            "desc": "App ID of the delegator contract."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "(address,byte[100])",
          "desc": "Address of delegator manager."
        },
        "desc": "Reports that keys of a delegator contract have not been confirmed in time."
      },
      {
        "name": "keys_not_submitted",
        "args": [
          {
            "type": "application",
            "name": "del_app",
            "desc": "App ID of the delegator contract."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "(address,byte[100])",
          "desc": "Address of delegator manager."
        },
        "desc": "Reports that keys of a delegator contract have not been submitted in time."
      },
      {
        "name": "keys_submit",
        "args": [
          {
            "type": "address",
            "name": "val_manager",
            "desc": "Purported validator manager account."
          },
          {
            "type": "application",
            "name": "del_app",
            "desc": "App ID of the delegator contract."
          },
          {
            "type": "(uint64,uint64,uint64,byte[32],byte[32],byte[64],address)",
            "name": "key_reg_txn_info",
            "desc": "Information about the generated participation keys."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "(address,byte[100])",
          "desc": "Address of delegator manager."
        },
        "desc": "Validator manager submits the keys generated for the delegator beneficiary according to the contract terms."
      },
      {
        "name": "breach_limits",
        "args": [
          {
            "type": "application",
            "name": "del_app",
            "desc": "App ID of the delegator contract."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "(bool,(uint64,uint64,uint64),address,byte[100])",
          "desc": "Boolean denoting if maximum number of breaches has already been reached (True) or not (False)."
        },
        "desc": "Reports that a limit breach event occurred on the delegator beneficiary."
      },
      {
        "name": "breach_pay",
        "args": [
          {
            "type": "application",
            "name": "del_app",
            "desc": "App ID of the delegator contract."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "(address,byte[100])",
          "desc": "Address of delegator manager."
        },
        "desc": "Reports that a payment for the fee cannot be made from the delegator contract.\nThis can happen if the DelegatorContract payment asset has been frozen or clawed back by the asset manager."
      },
      {
        "name": "breach_suspended",
        "args": [
          {
            "type": "application",
            "name": "del_app",
            "desc": "App ID of the delegator contract."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "((uint64,uint64,uint64),address,byte[100])",
          "desc": "Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."
        },
        "desc": "Reports that the delegator beneficiary was suspended by consensus."
      },
      {
        "name": "contract_claim",
        "args": [
          {
            "type": "application",
            "name": "del_app",
            "desc": "App ID of the delegator contract."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "(uint64,uint64,uint64)",
          "desc": "Amount of earnings of validator which equal any not yet claimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."
        },
        "desc": "Claims the operational fee up to this round from a delegator contract and\ntransfers it to the validator ad as well as the commission to the platform."
      },
      {
        "name": "contract_expired",
        "args": [
          {
            "type": "application",
            "name": "del_app",
            "desc": "App ID of the delegator contract."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "(address,byte[100])",
          "desc": "Address of delegator manager."
        },
        "desc": "Reports that a delegator contract has expired."
      },
      {
        "name": "contract_withdraw",
        "args": [
          {
            "type": "address",
            "name": "del_manager",
            "desc": "Purported delegator manager account."
          },
          {
            "type": "application",
            "name": "del_app",
            "desc": "App ID of the delegator contract."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Reports that a delegator has gracefully withdrawn from the contract prematurely.\nThe delegator beneficiary should issue a key deregistration transaction 320 round before this call."
      },
      {
        "name": "contract_delete",
        "args": [
          {
            "type": "address",
            "name": "del_manager",
            "desc": "Purported delegator manager account."
          },
          {
            "type": "application",
            "name": "del_app",
            "desc": "App ID of the delegator contract."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "(uint64,uint64)"
        },
        "desc": "Delegator deletes an ended contract, withdraws any remaining balance, and returns the MBR from ValidatorAd."
      },
      {
        "name": "contract_report_expiry_soon",
        "args": [
          {
            "type": "uint64",
            "name": "before_expiry",
            "desc": "How many rounds before contract end can the report be made."
          },
          {
            "type": "uint64",
            "name": "report_period",
            "desc": "How frequently can the report be made."
          },
          {
            "type": "application",
            "name": "del_app",
            "desc": "App ID of the delegator contract."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "(address,byte[100])",
          "desc": "Address of delegator manager."
        },
        "desc": "Reports that the contract will expire soon."
      },
      {
        "name": "gas",
        "args": [],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "To fit more resources in app reference arrays."
      },
      {
        "name": "get_validator_asa",
        "args": [
          {
            "type": "uint64",
            "name": "asset_id"
          }
        ],
        "readonly": true,
        "returns": {
          "type": "(uint64,uint64)",
          "desc": "Information about the payment asset that is or was accepted on the platform."
        },
        "desc": "Returns information about the ASA that is or was supported by the validator ad at any point of time before\ndeletion."
      }
    ],
    "networks": {}
  },
  "bare_call_config": {}
}

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt.
   */
  asBigInt(): bigint
  /**
   * Gets the state value as a number.
   */
  asNumber(): number
}
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array
  /**
   * Gets the state value as a string
   */
  asString(): string
}

export type AppCreateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult> & AppReference
export type AppUpdateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult>

export type AppClientComposeCallCoreParams = Omit<AppClientCallCoreParams, 'sendParams'> & {
  sendParams?: Omit<SendTransactionParams, 'skipSending' | 'atc' | 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources'>
}
export type AppClientComposeExecuteParams = Pick<SendTransactionParams, 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources' | 'suppressLog'>

export type IncludeSchema = {
  /**
   * Any overrides for the storage schema to request for the created app; by default the schema indicated by the app spec is used.
   */
  schema?: Partial<AppStorageSchema>
}

/**
 * Defines the types of available calls and state of the ValidatorAd smart contract.
 */
export type ValidatorAd = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'ad_create(address)uint64' | 'ad_create', {
      argsObj: {
        /**
         * Owner address for the validator ad.
         */
        valOwner: string
      }
      argsTuple: [valOwner: string]
      /**
       * App ID of the created validator ad application.
       */
      returns: bigint
    }>
    & Record<'ad_config(address,address,bool,uint64)void' | 'ad_config', {
      argsObj: {
        /**
         * Owner address of the validator ad.
         */
        valOwner: string
        /**
         * Manager address for the validator ad.
         */
        valManager: string
        /**
         * Set to True if validator ad should be accepting new delegators, otherwise set to False.
         */
        live: boolean
        /**
         * Maximum number of delegators the validator is willing to manage simultaneously.
         */
        cntDelMax: bigint | number
      }
      argsTuple: [valOwner: string, valManager: string, live: boolean, cntDelMax: bigint | number]
      returns: void
    }>
    & Record<'ad_delete(address)void' | 'ad_delete', {
      argsObj: {
        /**
         * Owner address of the validator ad.
         */
        valOwner: string
      }
      argsTuple: [valOwner: string]
      returns: void
    }>
    & Record<'ad_ready(address,bool)void' | 'ad_ready', {
      argsObj: {
        /**
         * Manager address for the validator ad.
         */
        valManager: string
        /**
         * Set to True if validator manager is ready for accepting new delegators, otherwise set to False.
         */
        ready: boolean
      }
      argsTuple: [valManager: string, ready: boolean]
      returns: void
    }>
    & Record<'ad_self_disclose(address,(byte[30],byte[60],byte[2],uint64,byte[20]))void' | 'ad_self_disclose', {
      argsObj: {
        /**
         * Owner address of the validator ad.
         */
        valOwner: string
        /**
         * Self-disclosed information about the validator.
         */
        valInfo: [Uint8Array, Uint8Array, Uint8Array, bigint | number, Uint8Array]
      }
      argsTuple: [valOwner: string, valInfo: [Uint8Array, Uint8Array, Uint8Array, bigint | number, Uint8Array]]
      returns: void
    }>
    & Record<'ad_terms(address,byte[32],(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64),((uint64,uint64)[2]),(uint64,uint64),pay)void' | 'ad_terms', {
      argsObj: {
        /**
         * Owner address of the validator ad.
         */
        valOwner: string
        /**
         * Hash (i.e. SHA 256) of the Terms and Conditions agreed by the validator.
         */
        tcSha256: Uint8Array
        /**
         * Validator's terms about timing.
         */
        termsTime: [bigint | number, bigint | number, bigint | number, bigint | number, bigint | number]
        /**
         * Validator's terms about pricing.
         */
        termsPrice: [bigint | number, bigint | number, bigint | number, bigint | number, bigint | number]
        /**
         * Validator's terms about stake limits.
         */
        termsStake: [bigint | number, bigint | number]
        /**
         * Validator's terms about gating requirements.
         */
        termsReqs: [[[bigint | number, bigint | number], [bigint | number, bigint | number]]]
        /**
         * Validator's terms about warnings.
         */
        termsWarn: [bigint | number, bigint | number]
        /**
         * Transaction for the payment of MBR increase.
         */
        txn: TransactionToSign | Transaction | Promise<SendTransactionResult>
      }
      argsTuple: [valOwner: string, tcSha256: Uint8Array, termsTime: [bigint | number, bigint | number, bigint | number, bigint | number, bigint | number], termsPrice: [bigint | number, bigint | number, bigint | number, bigint | number, bigint | number], termsStake: [bigint | number, bigint | number], termsReqs: [[[bigint | number, bigint | number], [bigint | number, bigint | number]]], termsWarn: [bigint | number, bigint | number], txn: TransactionToSign | Transaction | Promise<SendTransactionResult>]
      returns: void
    }>
    & Record<'ad_income(address,uint64)uint64' | 'ad_income', {
      argsObj: {
        /**
         * Owner address of the validator ad.
         */
        valOwner: string
        /**
         * ID of the asset (i.e. ASA ID or 0 for ALGO) for which the owner would like to withdraw all earnings from the validator ad.
         */
        assetId: bigint | number
      }
      argsTuple: [valOwner: string, assetId: bigint | number]
      /**
       * Withdrawn income from the validator ad for the input asset.
       */
      returns: bigint
    }>
    & Record<'ad_asa_close(address,uint64)void' | 'ad_asa_close', {
      argsObj: {
        /**
         * Owner address of the validator ad.
         */
        valOwner: string
        /**
         * ID of the asset (i.e. ASA ID or 0 for ALGO) for which the owner would like remove its storage.
         */
        assetId: bigint | number
      }
      argsTuple: [valOwner: string, assetId: bigint | number]
      returns: void
    }>
    & Record<'template_load_init(address,uint64,pay)void' | 'template_load_init', {
      argsObj: {
        /**
         * Owner address of the validator ad.
         */
        valOwner: string
        /**
         * Size of the delegator contract template in bytes.
         */
        templateSize: bigint | number
        /**
         * Payment transaction for the payment of the increase of validator ad MBR due to creation of box for storing the delegator contract template.
         */
        mbrTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>
      }
      argsTuple: [valOwner: string, templateSize: bigint | number, mbrTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>]
      returns: void
    }>
    & Record<'template_load_data(address,uint64,byte[])void' | 'template_load_data', {
      argsObj: {
        /**
         * Owner address of the validator ad.
         */
        valOwner: string
        /**
         * Offset in the box at which to replace the data.
         */
        offset: bigint | number
        /**
         * Data to replace in the box at the defined position.
         */
        data: Uint8Array
      }
      argsTuple: [valOwner: string, offset: bigint | number, data: Uint8Array]
      returns: void
    }>
    & Record<'template_load_end(address)void' | 'template_load_end', {
      argsObj: {
        /**
         * Owner address of the validator ad.
         */
        valOwner: string
      }
      argsTuple: [valOwner: string]
      returns: void
    }>
    & Record<'contract_create(address,address,uint64,uint64,address,(uint64,uint64),pay,txn)uint64' | 'contract_create', {
      argsObj: {
        /**
         * Manager address for the delegation contract.
         */
        delManager: string
        /**
         * Beneficiary address for the delegation contract.
         */
        delBeneficiary: string
        /**
         * Contract duration in number of rounds.
         */
        roundsDuration: bigint | number
        /**
         * The maximum amount of ALGO that the delegator beneficiary address intends to have at any point in time during the contract duration.
         */
        stakeMax: bigint | number
        /**
         * Address of the partner that collects the partner convenience fees. If there is no partner, set it to Global.zero_address.
         */
        partnerAddress: string
        /**
         * Commissions charged on top of validator setup and operational fees, for partner's convenience offer. The values are represented in ppm.
         */
        partnerCommissions: [bigint | number, bigint | number]
        /**
         * Payment transaction for the payment of the increase of validator ad MBR due to creation of a new contract.
         */
        mbrTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Transaction for the payment of the setup and operational fee.
         */
        txn: TransactionToSign | Transaction | Promise<SendTransactionResult>
      }
      argsTuple: [delManager: string, delBeneficiary: string, roundsDuration: bigint | number, stakeMax: bigint | number, partnerAddress: string, partnerCommissions: [bigint | number, bigint | number], mbrTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>, txn: TransactionToSign | Transaction | Promise<SendTransactionResult>]
      /**
       * App ID of the created delegator contract application.
       */
      returns: bigint
    }>
    & Record<'keys_confirm(address,application)void' | 'keys_confirm', {
      argsObj: {
        /**
         * Purported delegator manager account.
         */
        delManager: string
        delApp: number | bigint
      }
      argsTuple: [delManager: string, delApp: number | bigint]
      returns: void
    }>
    & Record<'keys_not_confirmed(application)(address,byte[100])' | 'keys_not_confirmed', {
      argsObj: {
        /**
         * App ID of the delegator contract.
         */
        delApp: number | bigint
      }
      argsTuple: [delApp: number | bigint]
      /**
       * Address of delegator manager.
       */
      returns: Message
    }>
    & Record<'keys_not_submitted(application)(address,byte[100])' | 'keys_not_submitted', {
      argsObj: {
        /**
         * App ID of the delegator contract.
         */
        delApp: number | bigint
      }
      argsTuple: [delApp: number | bigint]
      /**
       * Address of delegator manager.
       */
      returns: Message
    }>
    & Record<'keys_submit(address,application,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address))(address,byte[100])' | 'keys_submit', {
      argsObj: {
        /**
         * Purported validator manager account.
         */
        valManager: string
        /**
         * App ID of the delegator contract.
         */
        delApp: number | bigint
        /**
         * Information about the generated participation keys.
         */
        keyRegTxnInfo: [bigint | number, bigint | number, bigint | number, Uint8Array, Uint8Array, Uint8Array, string]
      }
      argsTuple: [valManager: string, delApp: number | bigint, keyRegTxnInfo: [bigint | number, bigint | number, bigint | number, Uint8Array, Uint8Array, Uint8Array, string]]
      /**
       * Address of delegator manager.
       */
      returns: Message
    }>
    & Record<'breach_limits(application)(bool,(uint64,uint64,uint64),address,byte[100])' | 'breach_limits', {
      argsObj: {
        /**
         * App ID of the delegator contract.
         */
        delApp: number | bigint
      }
      argsTuple: [delApp: number | bigint]
      /**
       * Boolean denoting if maximum number of breaches has already been reached (True) or not (False).
       */
      returns: BreachLimitsReturn
    }>
    & Record<'breach_pay(application)(address,byte[100])' | 'breach_pay', {
      argsObj: {
        /**
         * App ID of the delegator contract.
         */
        delApp: number | bigint
      }
      argsTuple: [delApp: number | bigint]
      /**
       * Address of delegator manager.
       */
      returns: Message
    }>
    & Record<'breach_suspended(application)((uint64,uint64,uint64),address,byte[100])' | 'breach_suspended', {
      argsObj: {
        /**
         * App ID of the delegator contract.
         */
        delApp: number | bigint
      }
      argsTuple: [delApp: number | bigint]
      /**
       * Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted.
       */
      returns: EarningsDistributionAndMessage
    }>
    & Record<'contract_claim(application)(uint64,uint64,uint64)' | 'contract_claim', {
      argsObj: {
        /**
         * App ID of the delegator contract.
         */
        delApp: number | bigint
      }
      argsTuple: [delApp: number | bigint]
      /**
       * Amount of earnings of validator which equal any not yet claimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted.
       */
      returns: EarningsDistribution
    }>
    & Record<'contract_expired(application)(address,byte[100])' | 'contract_expired', {
      argsObj: {
        /**
         * App ID of the delegator contract.
         */
        delApp: number | bigint
      }
      argsTuple: [delApp: number | bigint]
      /**
       * Address of delegator manager.
       */
      returns: Message
    }>
    & Record<'contract_withdraw(address,application)void' | 'contract_withdraw', {
      argsObj: {
        /**
         * Purported delegator manager account.
         */
        delManager: string
        /**
         * App ID of the delegator contract.
         */
        delApp: number | bigint
      }
      argsTuple: [delManager: string, delApp: number | bigint]
      returns: void
    }>
    & Record<'contract_delete(address,application)(uint64,uint64)' | 'contract_delete', {
      argsObj: {
        /**
         * Purported delegator manager account.
         */
        delManager: string
        /**
         * App ID of the delegator contract.
         */
        delApp: number | bigint
      }
      argsTuple: [delManager: string, delApp: number | bigint]
      returns: ContractDeleteReturn
    }>
    & Record<'contract_report_expiry_soon(uint64,uint64,application)(address,byte[100])' | 'contract_report_expiry_soon', {
      argsObj: {
        /**
         * How many rounds before contract end can the report be made.
         */
        beforeExpiry: bigint | number
        /**
         * How frequently can the report be made.
         */
        reportPeriod: bigint | number
        /**
         * App ID of the delegator contract.
         */
        delApp: number | bigint
      }
      argsTuple: [beforeExpiry: bigint | number, reportPeriod: bigint | number, delApp: number | bigint]
      /**
       * Address of delegator manager.
       */
      returns: Message
    }>
    & Record<'gas()void' | 'gas', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
    & Record<'get_validator_asa(uint64)(uint64,uint64)' | 'get_validator_asa', {
      argsObj: {
        assetId: bigint | number
      }
      argsTuple: [assetId: bigint | number]
      /**
       * Information about the payment asset that is or was accepted on the platform.
       */
      returns: ValidatorAsa
    }>
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      cntAsa?: IntegerState
      cntDel?: IntegerState
      cntDelMax?: IntegerState
      delAppList?: BinaryState
      noticeboardAppId?: IntegerState
      state?: BinaryState
      tcSha256?: BinaryState
      p?: BinaryState
      g?: BinaryState
      s?: BinaryState
      t?: BinaryState
      w?: BinaryState
      totalAlgoEarned?: IntegerState
      totalAlgoFeesGenerated?: IntegerState
      /**
       * Self-disclosed information about validator.
       */
      v?: BinaryState
      valManager?: BinaryState
      valOwner?: BinaryState
    }
  }
}
/**
 * Defines the possible abi call signatures
 */
export type ValidatorAdSig = keyof ValidatorAd['methods']
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends ValidatorAdSig | undefined> = {
  method: TSignature
  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>
} & AppClientCallCoreParams & CoreAppCallArgs
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>
/**
 * Represents a ValidatorSelfDisclosure result as a struct
 */
export type ValidatorSelfDisclosure = {
  name: Uint8Array
  https: Uint8Array
  countryCode: Uint8Array
  hwCat: bigint
  nodeVersion: Uint8Array
}
/**
 * Converts the tuple representation of a ValidatorSelfDisclosure to the struct representation
 */
export function ValidatorSelfDisclosure([name, https, countryCode, hwCat, nodeVersion]: [Uint8Array, Uint8Array, Uint8Array, bigint, Uint8Array] ) {
  return {
    name,
    https,
    countryCode,
    hwCat,
    nodeVersion,
  }
}
/**
 * Represents a ValidatorTermsTiming result as a struct
 */
export type ValidatorTermsTiming = {
  roundsSetup: bigint
  roundsConfirm: bigint
  roundsDurationMin: bigint
  roundsDurationMax: bigint
  roundMaxEnd: bigint
}
/**
 * Converts the tuple representation of a ValidatorTermsTiming to the struct representation
 */
export function ValidatorTermsTiming([roundsSetup, roundsConfirm, roundsDurationMin, roundsDurationMax, roundMaxEnd]: [bigint, bigint, bigint, bigint, bigint] ) {
  return {
    roundsSetup,
    roundsConfirm,
    roundsDurationMin,
    roundsDurationMax,
    roundMaxEnd,
  }
}
/**
 * Represents a ValidatorTermsPricing result as a struct
 */
export type ValidatorTermsPricing = {
  commission: bigint
  feeRoundMin: bigint
  feeRoundVar: bigint
  feeSetup: bigint
  feeAssetId: bigint
}
/**
 * Converts the tuple representation of a ValidatorTermsPricing to the struct representation
 */
export function ValidatorTermsPricing([commission, feeRoundMin, feeRoundVar, feeSetup, feeAssetId]: [bigint, bigint, bigint, bigint, bigint] ) {
  return {
    commission,
    feeRoundMin,
    feeRoundVar,
    feeSetup,
    feeAssetId,
  }
}
/**
 * Represents a ValidatorTermsStakeLimits result as a struct
 */
export type ValidatorTermsStakeLimits = {
  stakeMax: bigint
  stakeGratis: bigint
}
/**
 * Converts the tuple representation of a ValidatorTermsStakeLimits to the struct representation
 */
export function ValidatorTermsStakeLimits([stakeMax, stakeGratis]: [bigint, bigint] ) {
  return {
    stakeMax,
    stakeGratis,
  }
}
/**
 * Represents a ValidatorTermsGating result as a struct
 */
export type ValidatorTermsGating = {
  gatingAsaList: [[bigint, bigint], [bigint, bigint]]
}
/**
 * Converts the tuple representation of a ValidatorTermsGating to the struct representation
 */
export function ValidatorTermsGating([gatingAsaList]: [[[bigint, bigint], [bigint, bigint]]] ) {
  return {
    gatingAsaList,
  }
}
/**
 * Represents a ValidatorTermsWarnings result as a struct
 */
export type ValidatorTermsWarnings = {
  cntWarningMax: bigint
  roundsWarning: bigint
}
/**
 * Converts the tuple representation of a ValidatorTermsWarnings to the struct representation
 */
export function ValidatorTermsWarnings([cntWarningMax, roundsWarning]: [bigint, bigint] ) {
  return {
    cntWarningMax,
    roundsWarning,
  }
}
/**
 * Represents a PartnerCommissions result as a struct
 */
export type PartnerCommissions = {
  commissionSetup: bigint
  commissionOperational: bigint
}
/**
 * Converts the tuple representation of a PartnerCommissions to the struct representation
 */
export function PartnerCommissions([commissionSetup, commissionOperational]: [bigint, bigint] ) {
  return {
    commissionSetup,
    commissionOperational,
  }
}
/**
 * Represents a Message result as a struct
 */
export type Message = {
  delManager: string
  msg: Uint8Array
}
/**
 * Converts the tuple representation of a Message to the struct representation
 */
export function Message([delManager, msg]: [string, Uint8Array] ) {
  return {
    delManager,
    msg,
  }
}
/**
 * Represents a KeyRegTxnInfo result as a struct
 */
export type KeyRegTxnInfo = {
  voteFirst: bigint
  voteLast: bigint
  voteKeyDilution: bigint
  votePk: Uint8Array
  selectionPk: Uint8Array
  stateProofPk: Uint8Array
  sender: string
}
/**
 * Converts the tuple representation of a KeyRegTxnInfo to the struct representation
 */
export function KeyRegTxnInfo([voteFirst, voteLast, voteKeyDilution, votePk, selectionPk, stateProofPk, sender]: [bigint, bigint, bigint, Uint8Array, Uint8Array, Uint8Array, string] ) {
  return {
    voteFirst,
    voteLast,
    voteKeyDilution,
    votePk,
    selectionPk,
    stateProofPk,
    sender,
  }
}
/**
 * Represents a BreachLimitsReturn result as a struct
 */
export type BreachLimitsReturn = {
  maxBreachReached: boolean
  earningsDistribution: [bigint, bigint, bigint]
  delManager: string
  msg: Uint8Array
}
/**
 * Converts the tuple representation of a BreachLimitsReturn to the struct representation
 */
export function BreachLimitsReturn([maxBreachReached, earningsDistribution, delManager, msg]: [boolean, [bigint, bigint, bigint], string, Uint8Array] ) {
  return {
    maxBreachReached,
    earningsDistribution,
    delManager,
    msg,
  }
}
/**
 * Represents a EarningsDistributionAndMessage result as a struct
 */
export type EarningsDistributionAndMessage = {
  earningsDistribution: [bigint, bigint, bigint]
  delManager: string
  msg: Uint8Array
}
/**
 * Converts the tuple representation of a EarningsDistributionAndMessage to the struct representation
 */
export function EarningsDistributionAndMessage([earningsDistribution, delManager, msg]: [[bigint, bigint, bigint], string, Uint8Array] ) {
  return {
    earningsDistribution,
    delManager,
    msg,
  }
}
/**
 * Represents a EarningsDistribution result as a struct
 */
export type EarningsDistribution = {
  user: bigint
  platform: bigint
  assetId: bigint
}
/**
 * Converts the tuple representation of a EarningsDistribution to the struct representation
 */
export function EarningsDistribution([user, platform, assetId]: [bigint, bigint, bigint] ) {
  return {
    user,
    platform,
    assetId,
  }
}
/**
 * Represents a ContractDeleteReturn result as a struct
 */
export type ContractDeleteReturn = {
  remainingBalance: bigint
  assetId: bigint
}
/**
 * Converts the tuple representation of a ContractDeleteReturn to the struct representation
 */
export function ContractDeleteReturn([remainingBalance, assetId]: [bigint, bigint] ) {
  return {
    remainingBalance,
    assetId,
  }
}
/**
 * Represents a ValidatorASA result as a struct
 */
export type ValidatorAsa = {
  totalEarning: bigint
  totalFeesGenerated: bigint
}
/**
 * Converts the tuple representation of a ValidatorASA to the struct representation
 */
export function ValidatorAsa([totalEarning, totalFeesGenerated]: [bigint, bigint] ) {
  return {
    totalEarning,
    totalFeesGenerated,
  }
}
/**
 * Maps a method signature from the ValidatorAd smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends ValidatorAdSig> = ValidatorAd['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the ValidatorAd smart contract to the method's return type
 */
export type MethodReturn<TSignature extends ValidatorAdSig> = ValidatorAd['methods'][TSignature]['returns']

/**
 * A factory for available 'create' calls
 */
export type ValidatorAdCreateCalls = (typeof ValidatorAdCallFactory)['create']
/**
 * Defines supported create methods for this smart contract
 */
export type ValidatorAdCreateCallParams =
  | (TypedCallParams<'ad_create(address)uint64'> & (OnCompleteNoOp))
/**
 * A factory for available 'delete' calls
 */
export type ValidatorAdDeleteCalls = (typeof ValidatorAdCallFactory)['delete']
/**
 * Defines supported delete methods for this smart contract
 */
export type ValidatorAdDeleteCallParams =
  | TypedCallParams<'ad_delete(address)void'>
/**
 * Defines arguments required for the deploy method.
 */
export type ValidatorAdDeployArgs = {
  deployTimeParams?: TealTemplateParams
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: ValidatorAdCreateCalls) => ValidatorAdCreateCallParams
  /**
   * A delegate which takes a delete call factory and returns the delete call params for this smart contract
   */
  deleteCall?: (callFactory: ValidatorAdDeleteCalls) => ValidatorAdDeleteCallParams
}


/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class ValidatorAdCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the ValidatorAd smart contract using the ad_create(address)uint64 ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      adCreate(args: MethodArgs<'ad_create(address)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return {
          method: 'ad_create(address)uint64' as const,
          methodArgs: Array.isArray(args) ? args : [args.valOwner],
          ...params,
        }
      },
    }
  }

  /**
   * Gets available delete call factories
   */
  static get delete() {
    return {
      /**
       * Constructs a delete call for the ValidatorAd smart contract using the ad_delete(address)void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      adDelete(args: MethodArgs<'ad_delete(address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
        return {
          method: 'ad_delete(address)void' as const,
          methodArgs: Array.isArray(args) ? args : [args.valOwner],
          ...params,
        }
      },
    }
  }

  /**
   * Constructs a no op call for the ad_config(address,address,bool,uint64)void ABI method
   *
   * Sets all operation configuration parameters for the validator ad, i.e.
the validator manager account, the status whether the ad is live to accept new delegators (`live=True`) or not (`live=False`), and the maximum number of delegators the validators can accept.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static adConfig(args: MethodArgs<'ad_config(address,address,bool,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'ad_config(address,address,bool,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.valOwner, args.valManager, args.live, args.cntDelMax],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the ad_ready(address,bool)void ABI method
   *
   * Ad manager sets its readiness for operation.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static adReady(args: MethodArgs<'ad_ready(address,bool)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'ad_ready(address,bool)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.valManager, args.ready],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the ad_self_disclose(address,(byte[30],byte[60],byte[2],uint64,byte[20]))void ABI method
   *
   * Ad owner sets its self-disclosure information.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static adSelfDisclose(args: MethodArgs<'ad_self_disclose(address,(byte[30],byte[60],byte[2],uint64,byte[20]))void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'ad_self_disclose(address,(byte[30],byte[60],byte[2],uint64,byte[20]))void' as const,
      methodArgs: Array.isArray(args) ? args : [args.valOwner, args.valInfo],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the ad_terms(address,byte[32],(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64),((uint64,uint64)[2]),(uint64,uint64),pay)void ABI method
   *
   * Sets all the terms of the validator.
With this action, the validator agrees with the (new) terms.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static adTerms(args: MethodArgs<'ad_terms(address,byte[32],(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64),((uint64,uint64)[2]),(uint64,uint64),pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'ad_terms(address,byte[32],(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64),((uint64,uint64)[2]),(uint64,uint64),pay)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.valOwner, args.tcSha256, args.termsTime, args.termsPrice, args.termsStake, args.termsReqs, args.termsWarn, args.txn],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the ad_income(address,uint64)uint64 ABI method
   *
   * Validator owner withdraws all available balance from the validator ad for the given asset.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static adIncome(args: MethodArgs<'ad_income(address,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'ad_income(address,uint64)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.valOwner, args.assetId],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the ad_asa_close(address,uint64)void ABI method
   *
   * Removes the asset's storage on the validator ad.
To be used before deleting the contract.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static adAsaClose(args: MethodArgs<'ad_asa_close(address,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'ad_asa_close(address,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.valOwner, args.assetId],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the template_load_init(address,uint64,pay)void ABI method
   *
   * Starts the process of uploading delegator contract template.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static templateLoadInit(args: MethodArgs<'template_load_init(address,uint64,pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'template_load_init(address,uint64,pay)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.valOwner, args.templateSize, args.mbrTxn],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the template_load_data(address,uint64,byte[])void ABI method
   *
   * Uploads a data chunk to the delegator contract template.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static templateLoadData(args: MethodArgs<'template_load_data(address,uint64,byte[])void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'template_load_data(address,uint64,byte[])void' as const,
      methodArgs: Array.isArray(args) ? args : [args.valOwner, args.offset, args.data],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the template_load_end(address)void ABI method
   *
   * Ends uploading of the delegator contract template.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static templateLoadEnd(args: MethodArgs<'template_load_end(address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'template_load_end(address)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.valOwner],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the contract_create(address,address,uint64,uint64,address,(uint64,uint64),pay,txn)uint64 ABI method
   *
   * Creates a new delegator contract with the current delegation terms for the input
delegator contract manager and delegator contract beneficiary with the specified duration.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static contractCreate(args: MethodArgs<'contract_create(address,address,uint64,uint64,address,(uint64,uint64),pay,txn)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'contract_create(address,address,uint64,uint64,address,(uint64,uint64),pay,txn)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.delManager, args.delBeneficiary, args.roundsDuration, args.stakeMax, args.partnerAddress, args.partnerCommissions, args.mbrTxn, args.txn],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the keys_confirm(address,application)void ABI method
   *
   * Delegator manager confirms that the delegator beneficiary has confirmed the submitted keys
and pays for the operational fee.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static keysConfirm(args: MethodArgs<'keys_confirm(address,application)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'keys_confirm(address,application)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.delManager, args.delApp],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the keys_not_confirmed(application)(address,byte[100]) ABI method
   *
   * Reports that keys of a delegator contract have not been confirmed in time.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static keysNotConfirmed(args: MethodArgs<'keys_not_confirmed(application)(address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'keys_not_confirmed(application)(address,byte[100])' as const,
      methodArgs: Array.isArray(args) ? args : [args.delApp],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the keys_not_submitted(application)(address,byte[100]) ABI method
   *
   * Reports that keys of a delegator contract have not been submitted in time.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static keysNotSubmitted(args: MethodArgs<'keys_not_submitted(application)(address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'keys_not_submitted(application)(address,byte[100])' as const,
      methodArgs: Array.isArray(args) ? args : [args.delApp],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the keys_submit(address,application,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address))(address,byte[100]) ABI method
   *
   * Validator manager submits the keys generated for the delegator beneficiary according to the contract terms.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static keysSubmit(args: MethodArgs<'keys_submit(address,application,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address))(address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'keys_submit(address,application,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address))(address,byte[100])' as const,
      methodArgs: Array.isArray(args) ? args : [args.valManager, args.delApp, args.keyRegTxnInfo],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the breach_limits(application)(bool,(uint64,uint64,uint64),address,byte[100]) ABI method
   *
   * Reports that a limit breach event occurred on the delegator beneficiary.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static breachLimits(args: MethodArgs<'breach_limits(application)(bool,(uint64,uint64,uint64),address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'breach_limits(application)(bool,(uint64,uint64,uint64),address,byte[100])' as const,
      methodArgs: Array.isArray(args) ? args : [args.delApp],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the breach_pay(application)(address,byte[100]) ABI method
   *
   * Reports that a payment for the fee cannot be made from the delegator contract.
This can happen if the DelegatorContract payment asset has been frozen or clawed back by the asset manager.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static breachPay(args: MethodArgs<'breach_pay(application)(address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'breach_pay(application)(address,byte[100])' as const,
      methodArgs: Array.isArray(args) ? args : [args.delApp],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the breach_suspended(application)((uint64,uint64,uint64),address,byte[100]) ABI method
   *
   * Reports that the delegator beneficiary was suspended by consensus.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static breachSuspended(args: MethodArgs<'breach_suspended(application)((uint64,uint64,uint64),address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'breach_suspended(application)((uint64,uint64,uint64),address,byte[100])' as const,
      methodArgs: Array.isArray(args) ? args : [args.delApp],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the contract_claim(application)(uint64,uint64,uint64) ABI method
   *
   * Claims the operational fee up to this round from a delegator contract and
transfers it to the validator ad as well as the commission to the platform.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static contractClaim(args: MethodArgs<'contract_claim(application)(uint64,uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'contract_claim(application)(uint64,uint64,uint64)' as const,
      methodArgs: Array.isArray(args) ? args : [args.delApp],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the contract_expired(application)(address,byte[100]) ABI method
   *
   * Reports that a delegator contract has expired.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static contractExpired(args: MethodArgs<'contract_expired(application)(address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'contract_expired(application)(address,byte[100])' as const,
      methodArgs: Array.isArray(args) ? args : [args.delApp],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the contract_withdraw(address,application)void ABI method
   *
   * Reports that a delegator has gracefully withdrawn from the contract prematurely.
The delegator beneficiary should issue a key deregistration transaction 320 round before this call.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static contractWithdraw(args: MethodArgs<'contract_withdraw(address,application)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'contract_withdraw(address,application)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.delManager, args.delApp],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the contract_delete(address,application)(uint64,uint64) ABI method
   *
   * Delegator deletes an ended contract, withdraws any remaining balance, and returns the MBR from ValidatorAd.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static contractDelete(args: MethodArgs<'contract_delete(address,application)(uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'contract_delete(address,application)(uint64,uint64)' as const,
      methodArgs: Array.isArray(args) ? args : [args.delManager, args.delApp],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the contract_report_expiry_soon(uint64,uint64,application)(address,byte[100]) ABI method
   *
   * Reports that the contract will expire soon.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static contractReportExpirySoon(args: MethodArgs<'contract_report_expiry_soon(uint64,uint64,application)(address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'contract_report_expiry_soon(uint64,uint64,application)(address,byte[100])' as const,
      methodArgs: Array.isArray(args) ? args : [args.beforeExpiry, args.reportPeriod, args.delApp],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the gas()void ABI method
   *
   * To fit more resources in app reference arrays.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static gas(args: MethodArgs<'gas()void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'gas()void' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the get_validator_asa(uint64)(uint64,uint64) ABI method
   *
   * Returns information about the ASA that is or was supported by the validator ad at any point of time before
deletion.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getValidatorAsa(args: MethodArgs<'get_validator_asa(uint64)(uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'get_validator_asa(uint64)(uint64,uint64)' as const,
      methodArgs: Array.isArray(args) ? args : [args.assetId],
      ...params,
    }
  }
}

/**
 * A client to make calls to the ValidatorAd smart contract
 */
export class ValidatorAdClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient

  private readonly sender: SendTransactionFrom | undefined

  /**
   * Creates a new instance of `ValidatorAdClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender
    this.appClient = algokit.getAppClient({
      ...appDetails,
      app: APP_SPEC
    }, algod)
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<TReturn, TResult extends AppCallTransactionResult = AppCallTransactionResult>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> & TResult {
    if(result.return?.decodeError) {
      throw result.return.decodeError
    }
    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined
      ? returnValueFormatter(result.return.returnValue)
      : result.return?.returnValue as TReturn | undefined
      return { ...result, return: returnValue } as AppCallTransactionResultOfType<TReturn> & TResult
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof ValidatorAd['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {
    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)
  }

  /**
   * Idempotently deploys the ValidatorAd smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(params: ValidatorAdDeployArgs & AppClientDeployCoreParams & IncludeSchema = {}): ReturnType<ApplicationClient['deploy']> {
    const createArgs = params.createCall?.(ValidatorAdCallFactory.create)
    const deleteArgs = params.deleteCall?.(ValidatorAdCallFactory.delete)
    return this.appClient.deploy({
      ...params,
      deleteArgs,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    })
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this
    return {
      /**
       * Creates a new instance of the ValidatorAd smart contract using the ad_create(address)uint64 ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result: App ID of the created validator ad application.
       */
      async adCreate(args: MethodArgs<'ad_create(address)uint64'>, params: AppClientCallCoreParams & AppClientCompilationParams & IncludeSchema & CoreAppCallArgs & (OnCompleteNoOp) = {}) {
        return $this.mapReturnValue<MethodReturn<'ad_create(address)uint64'>, AppCreateCallTransactionResult>(await $this.appClient.create(ValidatorAdCallFactory.create.adCreate(args, params)))
      },
    }
  }

  /**
   * Gets available delete methods
   */
  public get delete() {
    const $this = this
    return {
      /**
       * Deletes an existing instance of the ValidatorAd smart contract using the ad_delete(address)void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The delete result
       */
      async adDelete(args: MethodArgs<'ad_delete(address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
        return $this.mapReturnValue<MethodReturn<'ad_delete(address)void'>>(await $this.appClient.delete(ValidatorAdCallFactory.delete.adDelete(args, params)))
      },
    }
  }

  /**
   * Makes a clear_state call to an existing instance of the ValidatorAd smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.appClient.clearState(args)
  }

  /**
   * Calls the ad_config(address,address,bool,uint64)void ABI method.
   *
   * Sets all operation configuration parameters for the validator ad, i.e.
the validator manager account, the status whether the ad is live to accept new delegators (`live=True`) or not (`live=False`), and the maximum number of delegators the validators can accept.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public adConfig(args: MethodArgs<'ad_config(address,address,bool,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.adConfig(args, params))
  }

  /**
   * Calls the ad_ready(address,bool)void ABI method.
   *
   * Ad manager sets its readiness for operation.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public adReady(args: MethodArgs<'ad_ready(address,bool)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.adReady(args, params))
  }

  /**
   * Calls the ad_self_disclose(address,(byte[30],byte[60],byte[2],uint64,byte[20]))void ABI method.
   *
   * Ad owner sets its self-disclosure information.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public adSelfDisclose(args: MethodArgs<'ad_self_disclose(address,(byte[30],byte[60],byte[2],uint64,byte[20]))void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.adSelfDisclose(args, params))
  }

  /**
   * Calls the ad_terms(address,byte[32],(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64),((uint64,uint64)[2]),(uint64,uint64),pay)void ABI method.
   *
   * Sets all the terms of the validator.
With this action, the validator agrees with the (new) terms.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public adTerms(args: MethodArgs<'ad_terms(address,byte[32],(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64),((uint64,uint64)[2]),(uint64,uint64),pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.adTerms(args, params))
  }

  /**
   * Calls the ad_income(address,uint64)uint64 ABI method.
   *
   * Validator owner withdraws all available balance from the validator ad for the given asset.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Withdrawn income from the validator ad for the input asset.
   */
  public adIncome(args: MethodArgs<'ad_income(address,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.adIncome(args, params))
  }

  /**
   * Calls the ad_asa_close(address,uint64)void ABI method.
   *
   * Removes the asset's storage on the validator ad.
To be used before deleting the contract.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public adAsaClose(args: MethodArgs<'ad_asa_close(address,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.adAsaClose(args, params))
  }

  /**
   * Calls the template_load_init(address,uint64,pay)void ABI method.
   *
   * Starts the process of uploading delegator contract template.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public templateLoadInit(args: MethodArgs<'template_load_init(address,uint64,pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.templateLoadInit(args, params))
  }

  /**
   * Calls the template_load_data(address,uint64,byte[])void ABI method.
   *
   * Uploads a data chunk to the delegator contract template.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public templateLoadData(args: MethodArgs<'template_load_data(address,uint64,byte[])void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.templateLoadData(args, params))
  }

  /**
   * Calls the template_load_end(address)void ABI method.
   *
   * Ends uploading of the delegator contract template.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public templateLoadEnd(args: MethodArgs<'template_load_end(address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.templateLoadEnd(args, params))
  }

  /**
   * Calls the contract_create(address,address,uint64,uint64,address,(uint64,uint64),pay,txn)uint64 ABI method.
   *
   * Creates a new delegator contract with the current delegation terms for the input
delegator contract manager and delegator contract beneficiary with the specified duration.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: App ID of the created delegator contract application.
   */
  public contractCreate(args: MethodArgs<'contract_create(address,address,uint64,uint64,address,(uint64,uint64),pay,txn)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.contractCreate(args, params))
  }

  /**
   * Calls the keys_confirm(address,application)void ABI method.
   *
   * Delegator manager confirms that the delegator beneficiary has confirmed the submitted keys
and pays for the operational fee.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public keysConfirm(args: MethodArgs<'keys_confirm(address,application)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.keysConfirm(args, params))
  }

  /**
   * Calls the keys_not_confirmed(application)(address,byte[100]) ABI method.
   *
   * Reports that keys of a delegator contract have not been confirmed in time.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Address of delegator manager.
   */
  public keysNotConfirmed(args: MethodArgs<'keys_not_confirmed(application)(address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.keysNotConfirmed(args, params), Message)
  }

  /**
   * Calls the keys_not_submitted(application)(address,byte[100]) ABI method.
   *
   * Reports that keys of a delegator contract have not been submitted in time.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Address of delegator manager.
   */
  public keysNotSubmitted(args: MethodArgs<'keys_not_submitted(application)(address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.keysNotSubmitted(args, params), Message)
  }

  /**
   * Calls the keys_submit(address,application,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address))(address,byte[100]) ABI method.
   *
   * Validator manager submits the keys generated for the delegator beneficiary according to the contract terms.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Address of delegator manager.
   */
  public keysSubmit(args: MethodArgs<'keys_submit(address,application,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address))(address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.keysSubmit(args, params), Message)
  }

  /**
   * Calls the breach_limits(application)(bool,(uint64,uint64,uint64),address,byte[100]) ABI method.
   *
   * Reports that a limit breach event occurred on the delegator beneficiary.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Boolean denoting if maximum number of breaches has already been reached (True) or not (False).
   */
  public breachLimits(args: MethodArgs<'breach_limits(application)(bool,(uint64,uint64,uint64),address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.breachLimits(args, params), BreachLimitsReturn)
  }

  /**
   * Calls the breach_pay(application)(address,byte[100]) ABI method.
   *
   * Reports that a payment for the fee cannot be made from the delegator contract.
This can happen if the DelegatorContract payment asset has been frozen or clawed back by the asset manager.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Address of delegator manager.
   */
  public breachPay(args: MethodArgs<'breach_pay(application)(address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.breachPay(args, params), Message)
  }

  /**
   * Calls the breach_suspended(application)((uint64,uint64,uint64),address,byte[100]) ABI method.
   *
   * Reports that the delegator beneficiary was suspended by consensus.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted.
   */
  public breachSuspended(args: MethodArgs<'breach_suspended(application)((uint64,uint64,uint64),address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.breachSuspended(args, params), EarningsDistributionAndMessage)
  }

  /**
   * Calls the contract_claim(application)(uint64,uint64,uint64) ABI method.
   *
   * Claims the operational fee up to this round from a delegator contract and
transfers it to the validator ad as well as the commission to the platform.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Amount of earnings of validator which equal any not yet claimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted.
   */
  public contractClaim(args: MethodArgs<'contract_claim(application)(uint64,uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.contractClaim(args, params), EarningsDistribution)
  }

  /**
   * Calls the contract_expired(application)(address,byte[100]) ABI method.
   *
   * Reports that a delegator contract has expired.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Address of delegator manager.
   */
  public contractExpired(args: MethodArgs<'contract_expired(application)(address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.contractExpired(args, params), Message)
  }

  /**
   * Calls the contract_withdraw(address,application)void ABI method.
   *
   * Reports that a delegator has gracefully withdrawn from the contract prematurely.
The delegator beneficiary should issue a key deregistration transaction 320 round before this call.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public contractWithdraw(args: MethodArgs<'contract_withdraw(address,application)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.contractWithdraw(args, params))
  }

  /**
   * Calls the contract_delete(address,application)(uint64,uint64) ABI method.
   *
   * Delegator deletes an ended contract, withdraws any remaining balance, and returns the MBR from ValidatorAd.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public contractDelete(args: MethodArgs<'contract_delete(address,application)(uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.contractDelete(args, params), ContractDeleteReturn)
  }

  /**
   * Calls the contract_report_expiry_soon(uint64,uint64,application)(address,byte[100]) ABI method.
   *
   * Reports that the contract will expire soon.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Address of delegator manager.
   */
  public contractReportExpirySoon(args: MethodArgs<'contract_report_expiry_soon(uint64,uint64,application)(address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.contractReportExpirySoon(args, params), Message)
  }

  /**
   * Calls the gas()void ABI method.
   *
   * To fit more resources in app reference arrays.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public gas(args: MethodArgs<'gas()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.gas(args, params))
  }

  /**
   * Calls the get_validator_asa(uint64)(uint64,uint64) ABI method.
   *
   * Returns information about the ASA that is or was supported by the validator ad at any point of time before
deletion.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Information about the payment asset that is or was accepted on the platform.
   */
  public getValidatorAsa(args: MethodArgs<'get_validator_asa(uint64)(uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorAdCallFactory.getValidatorAsa(args, params), ValidatorAsa)
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {
    const value = state[key]
    if (!value) return undefined
    if (!('valueRaw' in value))
      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)
    return {
      asString(): string {
        return value.value
      },
      asByteArray(): Uint8Array {
        return value.valueRaw
      }
    }
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {
    const value = state[key]
    if (!value) return undefined
    if ('valueRaw' in value)
      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)
    return {
      asBigInt() {
        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)
      },
      asNumber(): number {
        return typeof value.value === 'bigint' ? Number(value.value) : value.value
      },
    }
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<ValidatorAd['state']['global']> {
    const state = await this.appClient.getGlobalState()
    return {
      get cntAsa() {
        return ValidatorAdClient.getIntegerState(state, 'cnt_asa')
      },
      get cntDel() {
        return ValidatorAdClient.getIntegerState(state, 'cnt_del')
      },
      get cntDelMax() {
        return ValidatorAdClient.getIntegerState(state, 'cnt_del_max')
      },
      get delAppList() {
        return ValidatorAdClient.getBinaryState(state, 'del_app_list')
      },
      get noticeboardAppId() {
        return ValidatorAdClient.getIntegerState(state, 'noticeboard_app_id')
      },
      get state() {
        return ValidatorAdClient.getBinaryState(state, 'state')
      },
      get tcSha256() {
        return ValidatorAdClient.getBinaryState(state, 'tc_sha256')
      },
      get p() {
        return ValidatorAdClient.getBinaryState(state, 'P')
      },
      get g() {
        return ValidatorAdClient.getBinaryState(state, 'G')
      },
      get s() {
        return ValidatorAdClient.getBinaryState(state, 'S')
      },
      get t() {
        return ValidatorAdClient.getBinaryState(state, 'T')
      },
      get w() {
        return ValidatorAdClient.getBinaryState(state, 'W')
      },
      get totalAlgoEarned() {
        return ValidatorAdClient.getIntegerState(state, 'total_algo_earned')
      },
      get totalAlgoFeesGenerated() {
        return ValidatorAdClient.getIntegerState(state, 'total_algo_fees_generated')
      },
      get v() {
        return ValidatorAdClient.getBinaryState(state, 'V')
      },
      get valManager() {
        return ValidatorAdClient.getBinaryState(state, 'val_manager')
      },
      get valOwner() {
        return ValidatorAdClient.getBinaryState(state, 'val_owner')
      },
    }
  }

  public compose(): ValidatorAdComposer {
    const client = this
    const atc = new AtomicTransactionComposer()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: any) => any)> = []
    return {
      adConfig(args: MethodArgs<'ad_config(address,address,bool,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.adConfig(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      adReady(args: MethodArgs<'ad_ready(address,bool)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.adReady(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      adSelfDisclose(args: MethodArgs<'ad_self_disclose(address,(byte[30],byte[60],byte[2],uint64,byte[20]))void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.adSelfDisclose(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      adTerms(args: MethodArgs<'ad_terms(address,byte[32],(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64),((uint64,uint64)[2]),(uint64,uint64),pay)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.adTerms(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      adIncome(args: MethodArgs<'ad_income(address,uint64)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.adIncome(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      adAsaClose(args: MethodArgs<'ad_asa_close(address,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.adAsaClose(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      templateLoadInit(args: MethodArgs<'template_load_init(address,uint64,pay)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.templateLoadInit(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      templateLoadData(args: MethodArgs<'template_load_data(address,uint64,byte[])void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.templateLoadData(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      templateLoadEnd(args: MethodArgs<'template_load_end(address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.templateLoadEnd(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      contractCreate(args: MethodArgs<'contract_create(address,address,uint64,uint64,address,(uint64,uint64),pay,txn)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.contractCreate(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      keysConfirm(args: MethodArgs<'keys_confirm(address,application)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.keysConfirm(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      keysNotConfirmed(args: MethodArgs<'keys_not_confirmed(application)(address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.keysNotConfirmed(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(Message)
        return this
      },
      keysNotSubmitted(args: MethodArgs<'keys_not_submitted(application)(address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.keysNotSubmitted(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(Message)
        return this
      },
      keysSubmit(args: MethodArgs<'keys_submit(address,application,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address))(address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.keysSubmit(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(Message)
        return this
      },
      breachLimits(args: MethodArgs<'breach_limits(application)(bool,(uint64,uint64,uint64),address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.breachLimits(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(BreachLimitsReturn)
        return this
      },
      breachPay(args: MethodArgs<'breach_pay(application)(address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.breachPay(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(Message)
        return this
      },
      breachSuspended(args: MethodArgs<'breach_suspended(application)((uint64,uint64,uint64),address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.breachSuspended(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(EarningsDistributionAndMessage)
        return this
      },
      contractClaim(args: MethodArgs<'contract_claim(application)(uint64,uint64,uint64)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.contractClaim(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(EarningsDistribution)
        return this
      },
      contractExpired(args: MethodArgs<'contract_expired(application)(address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.contractExpired(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(Message)
        return this
      },
      contractWithdraw(args: MethodArgs<'contract_withdraw(address,application)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.contractWithdraw(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      contractDelete(args: MethodArgs<'contract_delete(address,application)(uint64,uint64)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.contractDelete(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(ContractDeleteReturn)
        return this
      },
      contractReportExpirySoon(args: MethodArgs<'contract_report_expiry_soon(uint64,uint64,application)(address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.contractReportExpirySoon(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(Message)
        return this
      },
      gas(args: MethodArgs<'gas()void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.gas(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getValidatorAsa(args: MethodArgs<'get_validator_asa(uint64)(uint64,uint64)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getValidatorAsa(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(ValidatorASA)
        return this
      },
      get delete() {
        const $this = this
        return {
          adDelete(args: MethodArgs<'ad_delete(address)void'>, params?: AppClientComposeCallCoreParams) {
            promiseChain = promiseChain.then(() => client.delete.adDelete(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
            resultMappers.push(undefined)
            return $this
          },
        }
      },
      clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {
        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))
        return this
      },
      async atc() {
        await promiseChain
        return atc
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await atc.simulate(client.algod, new modelsv2.SimulateRequest({ txnGroups: [], ...options }))
        return {
          ...result,
          returns: result.methodResults?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      },
      async execute(sendParams?: AppClientComposeExecuteParams) {
        await promiseChain
        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams }, client.algod)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      }
    } as unknown as ValidatorAdComposer
  }
}
export type ValidatorAdComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the ad_config(address,address,bool,uint64)void ABI method.
   *
   * Sets all operation configuration parameters for the validator ad, i.e.
the validator manager account, the status whether the ad is live to accept new delegators (`live=True`) or not (`live=False`), and the maximum number of delegators the validators can accept.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  adConfig(args: MethodArgs<'ad_config(address,address,bool,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'ad_config(address,address,bool,uint64)void'>]>

  /**
   * Calls the ad_ready(address,bool)void ABI method.
   *
   * Ad manager sets its readiness for operation.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  adReady(args: MethodArgs<'ad_ready(address,bool)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'ad_ready(address,bool)void'>]>

  /**
   * Calls the ad_self_disclose(address,(byte[30],byte[60],byte[2],uint64,byte[20]))void ABI method.
   *
   * Ad owner sets its self-disclosure information.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  adSelfDisclose(args: MethodArgs<'ad_self_disclose(address,(byte[30],byte[60],byte[2],uint64,byte[20]))void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'ad_self_disclose(address,(byte[30],byte[60],byte[2],uint64,byte[20]))void'>]>

  /**
   * Calls the ad_terms(address,byte[32],(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64),((uint64,uint64)[2]),(uint64,uint64),pay)void ABI method.
   *
   * Sets all the terms of the validator.
With this action, the validator agrees with the (new) terms.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  adTerms(args: MethodArgs<'ad_terms(address,byte[32],(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64),((uint64,uint64)[2]),(uint64,uint64),pay)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'ad_terms(address,byte[32],(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64),((uint64,uint64)[2]),(uint64,uint64),pay)void'>]>

  /**
   * Calls the ad_income(address,uint64)uint64 ABI method.
   *
   * Validator owner withdraws all available balance from the validator ad for the given asset.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  adIncome(args: MethodArgs<'ad_income(address,uint64)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'ad_income(address,uint64)uint64'>]>

  /**
   * Calls the ad_asa_close(address,uint64)void ABI method.
   *
   * Removes the asset's storage on the validator ad.
To be used before deleting the contract.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  adAsaClose(args: MethodArgs<'ad_asa_close(address,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'ad_asa_close(address,uint64)void'>]>

  /**
   * Calls the template_load_init(address,uint64,pay)void ABI method.
   *
   * Starts the process of uploading delegator contract template.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  templateLoadInit(args: MethodArgs<'template_load_init(address,uint64,pay)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'template_load_init(address,uint64,pay)void'>]>

  /**
   * Calls the template_load_data(address,uint64,byte[])void ABI method.
   *
   * Uploads a data chunk to the delegator contract template.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  templateLoadData(args: MethodArgs<'template_load_data(address,uint64,byte[])void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'template_load_data(address,uint64,byte[])void'>]>

  /**
   * Calls the template_load_end(address)void ABI method.
   *
   * Ends uploading of the delegator contract template.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  templateLoadEnd(args: MethodArgs<'template_load_end(address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'template_load_end(address)void'>]>

  /**
   * Calls the contract_create(address,address,uint64,uint64,address,(uint64,uint64),pay,txn)uint64 ABI method.
   *
   * Creates a new delegator contract with the current delegation terms for the input
delegator contract manager and delegator contract beneficiary with the specified duration.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  contractCreate(args: MethodArgs<'contract_create(address,address,uint64,uint64,address,(uint64,uint64),pay,txn)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'contract_create(address,address,uint64,uint64,address,(uint64,uint64),pay,txn)uint64'>]>

  /**
   * Calls the keys_confirm(address,application)void ABI method.
   *
   * Delegator manager confirms that the delegator beneficiary has confirmed the submitted keys
and pays for the operational fee.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  keysConfirm(args: MethodArgs<'keys_confirm(address,application)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'keys_confirm(address,application)void'>]>

  /**
   * Calls the keys_not_confirmed(application)(address,byte[100]) ABI method.
   *
   * Reports that keys of a delegator contract have not been confirmed in time.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  keysNotConfirmed(args: MethodArgs<'keys_not_confirmed(application)(address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'keys_not_confirmed(application)(address,byte[100])'>]>

  /**
   * Calls the keys_not_submitted(application)(address,byte[100]) ABI method.
   *
   * Reports that keys of a delegator contract have not been submitted in time.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  keysNotSubmitted(args: MethodArgs<'keys_not_submitted(application)(address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'keys_not_submitted(application)(address,byte[100])'>]>

  /**
   * Calls the keys_submit(address,application,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address))(address,byte[100]) ABI method.
   *
   * Validator manager submits the keys generated for the delegator beneficiary according to the contract terms.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  keysSubmit(args: MethodArgs<'keys_submit(address,application,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address))(address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'keys_submit(address,application,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address))(address,byte[100])'>]>

  /**
   * Calls the breach_limits(application)(bool,(uint64,uint64,uint64),address,byte[100]) ABI method.
   *
   * Reports that a limit breach event occurred on the delegator beneficiary.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  breachLimits(args: MethodArgs<'breach_limits(application)(bool,(uint64,uint64,uint64),address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'breach_limits(application)(bool,(uint64,uint64,uint64),address,byte[100])'>]>

  /**
   * Calls the breach_pay(application)(address,byte[100]) ABI method.
   *
   * Reports that a payment for the fee cannot be made from the delegator contract.
This can happen if the DelegatorContract payment asset has been frozen or clawed back by the asset manager.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  breachPay(args: MethodArgs<'breach_pay(application)(address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'breach_pay(application)(address,byte[100])'>]>

  /**
   * Calls the breach_suspended(application)((uint64,uint64,uint64),address,byte[100]) ABI method.
   *
   * Reports that the delegator beneficiary was suspended by consensus.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  breachSuspended(args: MethodArgs<'breach_suspended(application)((uint64,uint64,uint64),address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'breach_suspended(application)((uint64,uint64,uint64),address,byte[100])'>]>

  /**
   * Calls the contract_claim(application)(uint64,uint64,uint64) ABI method.
   *
   * Claims the operational fee up to this round from a delegator contract and
transfers it to the validator ad as well as the commission to the platform.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  contractClaim(args: MethodArgs<'contract_claim(application)(uint64,uint64,uint64)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'contract_claim(application)(uint64,uint64,uint64)'>]>

  /**
   * Calls the contract_expired(application)(address,byte[100]) ABI method.
   *
   * Reports that a delegator contract has expired.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  contractExpired(args: MethodArgs<'contract_expired(application)(address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'contract_expired(application)(address,byte[100])'>]>

  /**
   * Calls the contract_withdraw(address,application)void ABI method.
   *
   * Reports that a delegator has gracefully withdrawn from the contract prematurely.
The delegator beneficiary should issue a key deregistration transaction 320 round before this call.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  contractWithdraw(args: MethodArgs<'contract_withdraw(address,application)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'contract_withdraw(address,application)void'>]>

  /**
   * Calls the contract_delete(address,application)(uint64,uint64) ABI method.
   *
   * Delegator deletes an ended contract, withdraws any remaining balance, and returns the MBR from ValidatorAd.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  contractDelete(args: MethodArgs<'contract_delete(address,application)(uint64,uint64)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'contract_delete(address,application)(uint64,uint64)'>]>

  /**
   * Calls the contract_report_expiry_soon(uint64,uint64,application)(address,byte[100]) ABI method.
   *
   * Reports that the contract will expire soon.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  contractReportExpirySoon(args: MethodArgs<'contract_report_expiry_soon(uint64,uint64,application)(address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'contract_report_expiry_soon(uint64,uint64,application)(address,byte[100])'>]>

  /**
   * Calls the gas()void ABI method.
   *
   * To fit more resources in app reference arrays.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  gas(args: MethodArgs<'gas()void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'gas()void'>]>

  /**
   * Calls the get_validator_asa(uint64)(uint64,uint64) ABI method.
   *
   * Returns information about the ASA that is or was supported by the validator ad at any point of time before
deletion.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getValidatorAsa(args: MethodArgs<'get_validator_asa(uint64)(uint64,uint64)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, MethodReturn<'get_validator_asa(uint64)(uint64,uint64)'>]>

  /**
   * Gets available delete methods
   */
  readonly delete: {
    /**
     * Deletes an existing instance of the ValidatorAd smart contract using the ad_delete(address)void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    adDelete(args: MethodArgs<'ad_delete(address)void'>, params?: AppClientComposeCallCoreParams): ValidatorAdComposer<[...TReturns, MethodReturn<'ad_delete(address)void'>]>
  }

  /**
   * Makes a clear_state call to an existing instance of the ValidatorAd smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs): ValidatorAdComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): ValidatorAdComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(options?: SimulateOptions): Promise<ValidatorAdComposerSimulateResult<TReturns>>
  /**
   * Executes the transaction group and returns the results
   */
  execute(sendParams?: AppClientComposeExecuteParams): Promise<ValidatorAdComposerResults<TReturns>>
}
export type SimulateOptions = Omit<ConstructorParameters<typeof modelsv2.SimulateRequest>[0], 'txnGroups'>
export type ValidatorAdComposerSimulateResult<TReturns extends [...any[]]> = {
  returns: TReturns
  methodResults: ABIResult[]
  simulateResponse: modelsv2.SimulateResponse
}
export type ValidatorAdComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns
  groupId: string
  txIds: string[]
  transactions: Transaction[]
}
